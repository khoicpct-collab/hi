<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Simulation Tool</title>
    <!-- T·∫£i Office.js API ƒë·ªÉ giao ti·∫øp v·ªõi PowerPoint -->
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f4f7f9;
            color: #333;
            overflow-x: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        h2 {
            font-size: 1.25rem;
            color: #1a73e8;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
            margin-bottom: 10px;
        }
        .section {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .controls, .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        button, input[type="file"] {
            flex-grow: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        button:hover:not([disabled]) {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #a0c3e8;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-primary {
            background-color: #1a73e8;
            color: white;
        }
        .btn-secondary {
            background-color: #f0f0f0;
            color: #333;
        }
        
        .file-upload-label {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
            text-align: center;
        }

        .file-upload-label:hover {
            background-color: #45a049;
        }
        
        #materialImageUpload {
            display: none;
        }
        
        #mainCanvas {
            border: 2px dashed #ccc;
            border-radius: 6px;
            margin-top: 15px;
            width: 100%; /* ƒê·∫£m b·∫£o canvas chi·∫øm h·∫øt chi·ªÅu r·ªông */
            height: auto;
            cursor: default;
        }
        
        .drawing-mode {
            cursor: crosshair !important;
        }
        
        #msgStatus {
            padding: 10px;
            border-radius: 6px;
            background-color: #e3f2fd;
            color: #1a73e8;
            font-size: 0.875rem;
            text-align: center;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 8px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #1a73e8;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
    </style>
</head>
<body>

    <div id="loader" class="hidden">
        <div class="spinner"></div>
        <div id="loaderText">ƒêang x·ª≠ l√Ω...</div>
    </div>

    <div class="container">
        <div id="msgStatus">Vui l√≤ng kh·ªüi ƒë·ªông Add-in trong PowerPoint.</div>

        <div class="section">
            <h2>1. Thi·∫øt l·∫≠p N·ªÅn (Slide)</h2>
            <button id="btnSetContext" class="btn-primary">
                üìè K√≠ch ho·∫°t Canvas theo Slide
            </button>
            <p style="font-size: 0.8rem; margin-top: 5px;">
                *ƒê·∫£m b·∫£o b·∫°n ƒë√£ ch√®n GIF/Video v√†o Slide.
            </p>
        </div>

        <div class="section">
            <h2>2. V·∫≠t li·ªáu M√¥ ph·ªèng</h2>
            <input type="file" id="materialImageUpload" accept="image/png, image/jpeg">
            <label for="materialImageUpload" class="file-upload-label">
                üì§ T·∫£i ·∫¢nh H·∫°t (V·∫≠t li·ªáu)
            </label>
        </div>
        
        <div class="section">
            <h2>3. ƒê·ªãnh nghƒ©a V√πng Chuy·ªÉn ƒë·ªông</h2>
            <div class="controls">
                <button id="btnLine" class="btn-secondary" disabled>
                    ‚úèÔ∏è V·∫Ω ƒê∆∞·ªùng d·∫´n (Line)
                </button>
                <button id="btnVector" class="btn-secondary" disabled>
                    üñåÔ∏è V·∫Ω V√πng D√≤ng ch·∫£y (Vector)
                </button>
                <button id="btnReset" class="btn-secondary" disabled>
                    üóë X√≥a Path & H·∫°t
                </button>
            </div>
        </div>

        <canvas id="mainCanvas" width="800" height="600"></canvas>

        <div class="section">
            <h2>4. M√¥ ph·ªèng & Xu·∫•t file</h2>
            <div class="actions">
                <button id="btnSimulate" class="btn-primary" disabled>
                    ‚ñ∂ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG
                </button>
                <button id="btnExport" class="btn-primary" disabled>
                    üíæ XU·∫§T FRAME V√ÄO SLIDE
                </button>
            </div>
            <p style="font-size: 0.8rem; margin-top: 5px; color: #cc0000;">
                *Sau khi xu·∫•t, s·ª≠ d·ª•ng "File -> Export -> Create a Video" c·ªßa PowerPoint.
            </p>
        </div>

    </div>

    <script>
        // Kh·ªüi t·∫°o Office.js
        Office.onReady((info) => {
            if (info.host === Office.HostType.PowerPoint) {
                document.getElementById('msgStatus').textContent = "‚úÖ ƒê√£ k·∫øt n·ªëi v·ªõi PowerPoint. S·∫µn s√†ng!";
            }
        });
        
        // --- 1. C·∫§U H√åNH & STATE BAN ƒê·∫¶U ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Canvas ·∫©n ƒë·ªÉ t·∫°o mask (gi·ªØ l·∫°i t·ª´ code c≈©)
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');

        let state = {
            isSimulating: false,
            mode: 'idle', // idle, line, vector
            isDrawing: false,
            
            slideWidth: 800, // S·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t
            slideHeight: 600, // S·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t
            
            materialImage: null,
            paths: [],
            particles: [],
            
            time: 0,
            lastFrameTime: 0,
            
            simParams: {
                maxParticles: 500,
                spawnRate: 15, // h·∫°t/gi√¢y
                particleSize: 5,
                particleLifetime: 3000, // ms
                lineSpeed: 120, // px/s
                vectorFlowSpeed: 80, // px/s
            }
        };

        let currentPath = null;
        let animFrameId = null;

        const ui = {
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loaderText'),
            msg: document.getElementById('msgStatus'),
            btnSetContext: document.getElementById('btnSetContext'),
            btnLine: document.getElementById('btnLine'),
            btnVector: document.getElementById('btnVector'),
            btnSim: document.getElementById('btnSimulate'),
            btnExport: document.getElementById('btnExport'),
            btnReset: document.getElementById('btnReset'),
        };

        // --- 2. H√ÄM H·ªñ TR·ª¢ V√Ä UI ---
        
        function showLoader(text) {
            ui.loaderText.textContent = text;
            ui.loader.classList.remove('hidden');
        }

        function hideLoader() {
            ui.loader.classList.add('hidden');
        }

        function enableTools(enable) {
            ui.btnLine.disabled = !enable;
            ui.btnVector.disabled = !enable;
            ui.btnSim.disabled = !enable;
            ui.btnExport.disabled = !enable;
            ui.btnReset.disabled = !enable;
        }

        function resizeCanvas(w, h) {
            state.slideWidth = w;
            state.slideHeight = h;
            
            canvas.width = w;
            canvas.height = h;
            maskCanvas.width = w;
            maskCanvas.height = h;

            // ƒê·∫∑t Canvas ƒë·ªÉ v·ª´a v·ªõi Task Pane (T·ª∑ l·ªá c·ªë ƒë·ªãnh)
            const parentWidth = canvas.parentElement.clientWidth;
            const aspectRatio = w / h;
            
            canvas.style.width = parentWidth + 'px';
            canvas.style.height = (parentWidth / aspectRatio) + 'px';
            
            drawMain();
        }

        function setMode(m) {
            state.mode = m;
            canvas.classList.toggle('drawing-mode', m !== 'idle');
            ui.msg.textContent = m === 'line' 
                ? "‚úèÔ∏è V·∫Ω Line: K√©o chu·ªôt t·∫°o ƒë∆∞·ªùng d·∫´n." 
                : "üñåÔ∏è V·∫Ω V√πng: V·∫Ω v√≤ng tr√≤n kh√©p k√≠n. Nh·∫•n n√∫t chu·ªôt l√™n ƒë·ªÉ k·∫øt th√∫c.";
        }

        // --- 3. GIAO TI·∫æP V·ªöI POWERPOINT (OFFICE.JS) ---
        
        ui.btnSetContext.addEventListener('click', setSlideContext);
        
        async function setSlideContext() {
            if (!Office.context.document) {
                ui.msg.textContent = "‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi Office Context.";
                return;
            }

            showLoader("ƒêang l·∫•y k√≠ch th∆∞·ªõc Slide...");
            
            try {
                // S·ª≠ d·ª•ng Office.js ƒë·ªÉ truy c·∫≠p PowerPoint
                await PowerPoint.run(async (context) => {
                    // L·∫•y slide ƒë·∫ßu ti√™n
                    const slide = context.presentation.slides.getItemAt(0);
                    slide.load("width, height");
                    await context.sync();
                    
                    const width = slide.width;
                    const height = slide.height;
                    
                    // C·∫≠p nh·∫≠t Canvas theo k√≠ch th∆∞·ªõc Slide
                    resizeCanvas(width, height);
                    
                    enableTools(true);
                    ui.btnSetContext.disabled = true;
                    ui.msg.textContent = `‚úÖ Canvas ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p: ${width.toFixed(0)} x ${height.toFixed(0)} px.`;
                });
            } catch (error) {
                console.error("L·ªói khi l·∫•y k√≠ch th∆∞·ªõc slide:", error);
                ui.msg.textContent = "‚ùå L·ªói: Kh√¥ng th·ªÉ ƒë·ªçc k√≠ch th∆∞·ªõc slide. Vui l√≤ng th·ª≠ l·∫°i.";
                enableTools(false);
            } finally {
                hideLoader();
            }
        }
        
        // --- 4. T·∫¢I V·∫¨T LI·ªÜU ---
        document.getElementById('materialImageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                showLoader("ƒêang t·∫£i v·∫≠t li·ªáu...");
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(resolve => img.onload = resolve);
                state.materialImage = await createImageBitmap(img);
                
                // ƒê·∫∑t k√≠ch th∆∞·ªõc h·∫°t theo ·∫£nh (v√≠ d·ª•)
                state.simParams.particleSize = Math.max(5, Math.min(15, img.naturalWidth / 5)); 
                
                ui.msg.textContent = `‚úÖ ƒê√£ t·∫£i ·∫£nh v·∫≠t li·ªáu (${file.name}). S·∫µn s√†ng v·∫Ω Path.`;
                hideLoader();
                drawMain();
            }
        });

        // --- 5. LOGIC V·∫º PATH & VECTOR ---
        
        const getPos = (e) => {
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            return {
                x: (e.clientX - r.left) * scaleX,
                y: (e.clientY - r.top) * scaleY
            };
        };

        // B·∫Øt ƒë·∫ßu v·∫Ω
        canvas.addEventListener('mousedown', (e) => {
            if (state.mode === 'idle') return;
            state.isDrawing = true;
            const pos = getPos(e);
            
            currentPath = {
                type: state.mode,
                points: [{ ...pos, angle: 0 }],
                length: 0,
                particlesSpawned: 0,
                flowVector: null, // Ch·ªâ d√πng cho type='vector'
                com: {x: pos.x, y: pos.y}, // ƒêi·ªÉm trung t√¢m cho Vector
            };
        });

        // ƒêang v·∫Ω
        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDrawing || state.mode === 'idle') return;
            const pos = getPos(e);

            const lastPoint = currentPath.points[currentPath.points.length - 1];
            const dist = Math.hypot(pos.x - lastPoint.x, pos.y - lastPoint.y);

            if (dist > 3) { // Gi·ªõi h·∫°n kho·∫£ng c√°ch gi·ªØa c√°c ƒëi·ªÉm
                let angle = Math.atan2(pos.y - lastPoint.y, pos.x - lastPoint.x);
                currentPath.points.push({ ...pos, angle });
                currentPath.length += dist;
            }
            drawMain();
        });

        // K·∫øt th√∫c v·∫Ω
        canvas.addEventListener('mouseup', () => {
            if (!state.isDrawing || state.mode === 'idle' || !currentPath || currentPath.points.length < 2) {
                state.isDrawing = false;
                currentPath = null;
                return;
            }

            if (state.mode === 'vector') {
                // ƒê√≥ng v√πng vector
                calcVector(currentPath);
                state.paths.push(currentPath);
                initParticles(currentPath); // Spawn h·∫°t ban ƒë·∫ßu
                ui.msg.textContent = `‚úÖ ƒê√£ t·∫°o v√πng D√≤ng ch·∫£y.`;
            } else if (state.mode === 'line') {
                // L∆∞u ƒë∆∞·ªùng line
                state.paths.push(currentPath);
                ui.msg.textContent = `‚úÖ ƒê√£ t·∫°o ƒê∆∞·ªùng d·∫´n (Line).`;
            }
            
            currentPath = null;
            state.isDrawing = false;
            setMode('idle');
            drawMain();
        });

        // G√°n vector l·ª±c cho v√πng k√≠n
        function calcVector(path) {
             // 1. T√≠nh Center of Mass (COM)
            let sumX = 0, sumY = 0;
            for(const p of path.points) { sumX += p.x; sumY += p.y; }
            path.com = { x: sumX / path.points.length, y: sumY / path.points.length };

            // 2. T·∫†O TR∆Ø·ªúNG VECTOR NG·∫™U NHI√äN 
            const angle = Math.random() * Math.PI * 2;
            path.flowVector = {
                vx: Math.cos(angle) * state.simParams.vectorFlowSpeed,
                vy: Math.sin(angle) * state.simParams.vectorFlowSpeed
            };
        }

        // Ki·ªÉm tra Point-in-Polygon
        function isPointInPath(point, path) {
            if (path.type !== 'vector') return false;

            let inside = false;
            const points = path.points;
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x, yi = points[i].y;
                const xj = points[j].x, yj = points[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }


        // --- 6. LOGIC H·∫†T (PARTICLES) ---

        // Spawn m·ªôt h·∫°t m·ªõi
        function spawnParticle(path) {
            const startPoint = path.points[0];
            const size = state.simParams.particleSize;
            
            // T√≠nh v·∫≠n t·ªëc ban ƒë·∫ßu d·ª±a tr√™n ƒëi·ªÉm ƒë·∫ßu v√† ƒëi·ªÉm th·ª© 1 ho·∫∑c 2
            let nextPoint = path.points[1] || path.points[0];
            
            const angle = Math.atan2(nextPoint.y - startPoint.y, nextPoint.x - startPoint.x);
            
            state.particles.push({
                x: startPoint.x,
                y: startPoint.y,
                vx: Math.cos(angle) * state.simParams.lineSpeed, 
                vy: Math.sin(angle) * state.simParams.lineSpeed,
                pathIndex: 0, // D√πng cho Line: index c·ªßa ƒëi·ªÉm ƒë√£ ƒëi qua
                pathRef: path, // Tham chi·∫øu ƒë·∫øn path
                life: state.simParams.particleLifetime, // Tu·ªïi th·ªç
                pathType: path.type, // L∆∞u l·∫°i lo·∫°i path
                size: size,
                distanceTravelled: 0, // Theo d√µi kho·∫£ng c√°ch ƒë√£ ƒëi
            });
            path.particlesSpawned++;
        }
        
        // Spawn h·∫°t ban ƒë·∫ßu (c≈©ng d√πng cho ch·∫ø ƒë·ªô Vector ƒë·ªÉ t·∫°o h·∫°t)
        function initParticles(path) {
            if (path.type === 'line') {
                 // Spawn ngay l·∫≠p t·ª©c v√†i h·∫°t tr√™n ƒë∆∞·ªùng line
                for (let i = 0; i < 5; i++) {
                    // Spawn h·∫°t v·ªõi v·ªã tr√≠ ng·∫´u nhi√™n tr√™n ƒë∆∞·ªùng line ban ƒë·∫ßu
                    const pointIndex = Math.floor(Math.random() * (path.points.length - 1));
                    spawnParticle(path);
                }
            } else if (path.type === 'vector') {
                 // Spawn ng·∫´u nhi√™n trong v√πng Vector
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of path.points) {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                }
                
                const initialCount = 50;
                for (let i = 0; i < initialCount; i++) {
                    let attempts = 0;
                    let p;
                    do {
                        p = {
                            x: minX + Math.random() * (maxX - minX),
                            y: minY + Math.random() * (maxY - minY)
                        };
                        attempts++;
                    } while (!isPointInPath(p, path) && attempts < 100);
                    
                    if (isPointInPath(p, path)) {
                        state.particles.push({
                            ...p,
                            vx: path.flowVector.vx, // V·∫≠n t·ªëc ban ƒë·∫ßu theo vector
                            vy: path.flowVector.vy,
                            pathRef: path,
                            life: state.simParams.particleLifetime,
                            pathType: path.type,
                            size: state.simParams.particleSize,
                        });
                    }
                }
            }
        }
        
        // --- 7. V√íNG L·∫∂P M√î PH·ªéNG (UPDATE & DRAW) ---

        ui.btnSim.addEventListener('click', () => {
            if (state.paths.length === 0) {
                // Thay th·∫ø alert b·∫±ng UI th√¥ng b√°o
                ui.msg.textContent = "‚ö†Ô∏è Vui l√≤ng v·∫Ω ƒê∆∞·ªùng d·∫´n ho·∫∑c V√πng D√≤ng ch·∫£y tr∆∞·ªõc!";
                return;
            }
            
            state.isSimulating = !state.isSimulating;
            ui.btnSim.textContent = state.isSimulating ? "‚è∏ T·∫†M D·ª™NG" : "‚ñ∂ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG";
            
            if(state.isSimulating) loop();
            else cancelAnimationFrame(animFrameId);
        });

        function loop(timestamp) {
            if(!state.isSimulating) return;
            if(!timestamp) timestamp = performance.now();
            
            const dt = timestamp - (state.lastFrameTime || timestamp);
            state.lastFrameTime = timestamp;
            state.time += dt;

            update(dt);
            drawMain();
            animFrameId = requestAnimationFrame(loop);
        }

        // C·∫≠p nh·∫≠t v·ªã tr√≠ h·∫°t
        function update(dt) {
            const dtSeconds = dt / 1000;

            // 1. Spawn h·∫°t m·ªõi (ch·ªâ cho Line)
            for (const path of state.paths.filter(p => p.type === 'line')) {
                // T·∫ßn su·∫•t spawn: 1 h·∫°t sau m·ªói (1000 / spawnRate) ms
                if (Math.random() * 1000 < state.simParams.spawnRate) {
                    spawnParticle(path);
                }
            }

            // 2. C·∫≠p nh·∫≠t v·ªã tr√≠ v√† tr·∫°ng th√°i h·∫°t
            state.particles = state.particles.filter(particle => {
                particle.life -= dt;

                if (particle.life <= 0) return false; // H·∫°t h·∫øt tu·ªïi th·ªç

                if (particle.pathType === 'line') {
                    // Logic di chuy·ªÉn theo ƒë∆∞·ªùng Line
                    const path = particle.pathRef;
                    
                    // ƒêi·ªÉm ƒë√≠ch hi·ªán t·∫°i
                    const targetPoint = path.points[particle.pathIndex + 1];

                    if (!targetPoint) return false; // H·∫°t ƒë√£ ƒëi h·∫øt ƒë∆∞·ªùng

                    // T√≠nh to√°n vector h∆∞·ªõng ƒë·∫øn ƒëi·ªÉm ƒë√≠ch
                    const dx = targetPoint.x - particle.x;
                    const dy = targetPoint.y - particle.y;
                    const distanceToTarget = Math.hypot(dx, dy);

                    if (distanceToTarget < 1) {
                        // ƒê√£ ƒë·∫øn ƒëi·ªÉm ƒë√≠ch, chuy·ªÉn sang ƒëi·ªÉm ti·∫øp theo
                        particle.pathIndex++;
                        if (particle.pathIndex + 1 >= path.points.length) {
                             // H·∫°t ƒëi h·∫øt ƒë∆∞·ªùng, k·∫øt th√∫c
                             return false; 
                        }
                        const nextTarget = path.points[particle.pathIndex + 1];
                        // C·∫≠p nh·∫≠t v·∫≠n t·ªëc h∆∞·ªõng v·ªÅ ƒëi·ªÉm m·ªõi
                        const angle = Math.atan2(nextTarget.y - targetPoint.y, nextTarget.x - targetPoint.x);
                        particle.vx = Math.cos(angle) * state.simParams.lineSpeed;
                        particle.vy = Math.sin(angle) * state.simParams.lineSpeed;
                    } else {
                        // Di chuy·ªÉn b√¨nh th∆∞·ªùng
                        particle.x += particle.vx * dtSeconds;
                        particle.y += particle.vy * dtSeconds;
                    }
                
                } else if (particle.pathType === 'vector') {
                    // Logic D√≤ng ch·∫£y (Vector Field)
                    const path = particle.pathRef;

                    if (isPointInPath(particle, path)) {
                        // √Åp d·ª•ng l·ª±c D√≤ng ch·∫£y
                        particle.x += path.flowVector.vx * dtSeconds;
                        particle.y += path.flowVector.vy * dtSeconds;

                        // Gi·ªØ tu·ªïi th·ªç ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng tu·∫ßn ho√†n
                        // N·∫øu h·∫°t v·∫´n trong v√πng, n√≥ c√≥ th·ªÉ "h·ªìi ph·ª•c" tu·ªïi th·ªç
                        particle.life = Math.min(particle.life + dt * 0.1, state.simParams.particleLifetime);
                    } else {
                        // H·∫°t tr√¥i ra ngo√†i v√πng, gi·∫£m t·ªëc v√† m·∫•t tu·ªïi th·ªç nhanh h∆°n
                        particle.vx *= 0.99; // Gi·∫£m t·ªëc nh·∫π
                        particle.vy *= 0.99;
                        
                        particle.x += particle.vx * dtSeconds;
                        particle.y += particle.vy * dtSeconds;
                    }
                }
                
                // Ki·ªÉm tra gi·ªõi h·∫°n m√†n h√¨nh (√°p d·ª•ng cho Vector)
                if (particle.pathType === 'vector' && 
                    (particle.x < 0 || particle.x > canvas.width || particle.y < 0 || particle.y > canvas.height)) {
                    return false; // H·∫°t tr√¥i ra kh·ªèi m√†n h√¨nh
                }
                
                return true;
            });
            
            // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng h·∫°t
            if (state.particles.length > state.simParams.maxParticles) {
                state.particles = state.particles.slice(state.particles.length - state.simParams.maxParticles);
            }
        }

        function drawMain() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω c√°c Path/Vector (ch·ªâ ƒë·ªÉ xem, kh√¥ng xu·∫•t)
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            
            for (const path of state.paths) {
                ctx.beginPath();
                ctx.moveTo(path.points[0].x, path.points[0].y);
                
                if (path.type === 'line') {
                    ctx.strokeStyle = '#f90'; // M√†u cam cho Line
                } else if (path.type === 'vector') {
                    ctx.strokeStyle = '#1a73e8'; // M√†u xanh cho Vector
                }
                
                for (let i = 1; i < path.points.length; i++) {
                    ctx.lineTo(path.points[i].x, path.points[i].y);
                }

                if (path.type === 'vector') {
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(26, 115, 232, 0.1)';
                    ctx.fill();
                    
                    // V·∫Ω vector ch·ªâ h∆∞·ªõng (V√≠ d·ª•: t·∫°i trung t√¢m v√πng)
                    if (path.flowVector) {
                         const cx = path.com.x;
                         const cy = path.com.y;
                         
                         const vx = path.flowVector.vx / 3; // Gi·∫£m ƒë·ªô d√†i hi·ªÉn th·ªã
                         const vy = path.flowVector.vy / 3;
                         
                         ctx.strokeStyle = '#0a428c';
                         ctx.lineWidth = 4;
                         ctx.beginPath();
                         ctx.moveTo(cx, cy);
                         ctx.lineTo(cx + vx, cy + vy);
                         ctx.stroke();
                         // V·∫Ω ƒë·∫ßu m≈©i t√™n
                         drawArrowhead(ctx, cx + vx, cy + vy, Math.atan2(vy, vx), 10);
                    }
                }
                
                ctx.stroke();
            }
            
            // H√†m v·∫Ω ƒë·∫ßu m≈©i t√™n
            function drawArrowhead(ctx, x, y, angle, size) {
                ctx.save();
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, size / 2);
                ctx.lineTo(-size, -size / 2);
                ctx.closePath();
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fill();
                ctx.restore();
            }

            // 2. V·∫Ω n√©t ƒëang v·∫Ω
            if (state.isDrawing && currentPath) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(currentPath.points[0].x, currentPath.points[0].y);
                for (let i = 1; i < currentPath.points.length; i++) {
                    ctx.lineTo(currentPath.points[i].x, currentPath.points[i].y);
                }
                ctx.stroke();
            }

            // 3. V·∫Ω H·∫°t (Particles)
            for (const p of state.particles) {
                ctx.globalAlpha = p.life / state.simParams.particleLifetime;
                
                if (state.materialImage) {
                    // V·∫Ω ·∫£nh v·∫≠t li·ªáu
                    ctx.drawImage(state.materialImage, p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                } else {
                    // V·∫Ω h√¨nh tr√≤n m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ ·∫£nh v·∫≠t li·ªáu
                    ctx.fillStyle = '#4CAF50';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1; // Reset
            }
        }
        
        // --- 8. XU·∫§T FILE T√çCH H·ª¢P POWERPOINT ---
        
        ui.btnExport.addEventListener('click', () => {
            if (state.particles.length === 0) {
                ui.msg.textContent = "‚ö†Ô∏è Vui l√≤ng ch·∫°y m√¥ ph·ªèng v√† c√≥ h·∫°t tr√™n m√†n h√¨nh tr∆∞·ªõc khi xu·∫•t!";
                return;
            }
            exportFramesToPowerPoint();
        });

        async function exportFramesToPowerPoint() {
            if (!Office.context.document) return;
            
            showLoader("B·∫Øt ƒë·∫ßu xu·∫•t khung h√¨nh (Frames)...");
            
            const wasSimulating = state.isSimulating;
            state.isSimulating = false; // T·∫°m d·ª´ng v√≤ng l·∫∑p requestAnimationFrame
            
            const frameCount = 60; // S·ªë l∆∞·ª£ng frame xu·∫•t (t∆∞∆°ng ƒë∆∞∆°ng 3 gi√¢y ·ªü 20 FPS)
            const durationPerFrame = 50; // ms (20 FPS = 1000ms / 50ms)
            
            try {
                
                await PowerPoint.run(async (context) => {
                    // L·∫•y slide hi·ªán t·∫°i, n·∫øu kh√¥ng c√≥, l·∫•y slide ƒë·∫ßu ti√™n
                    const slide = context.presentation.slides.getItemAt(0);
                    
                    for (let i = 0; i < frameCount; i++) {
                        showLoader(`Xu·∫•t Frame ${i + 1}/${frameCount} (20 FPS)...`);
                        
                        // 1. C·∫≠p nh·∫≠t tr·∫°ng th√°i m√¥ ph·ªèng
                        update(durationPerFrame); 
                        drawMain();
                        
                        // 2. L·∫•y Base64 c·ªßa Canvas
                        const imageDataUrl = canvas.toDataURL("image/png");
                        const base64Image = imageDataUrl.split(',')[1];
                        
                        // 3. Ch√®n ·∫£nh v√†o slide (overlay)
                        // H√¨nh ·∫£nh s·∫Ω ƒë∆∞·ª£c cƒÉn ch·ªânh ƒë√∫ng k√≠ch th∆∞·ªõc Slide (left: 0, top: 0)
                        slide.shapes.addImage(base64Image, { 
                            left: 0, 
                            top: 0, 
                            width: state.slideWidth, 
                            height: state.slideHeight 
                        });
                        
                        // C·∫ßn sync sau m·ªói l·∫ßn th√™m h√¨nh ·∫£nh (v√¨ ƒë√¢y l√† m·ªôt thao t√°c l·ªõn)
                        await context.sync(); 
                    }
                    
                    // Th√™m h∆∞·ªõng d·∫´n v√†o slide cu·ªëi c√πng (Ch·ªâ ƒë·ªÉ h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng)
                    const lastSlide = context.presentation.slides.getLast();
                    lastSlide.shapes.addTextBox("Sau khi xu·∫•t xong, d√πng ch·ª©c nƒÉng 'File -> Export -> Create a Video' c·ªßa PowerPoint ƒë·ªÉ t·∫°o file ƒë·ªông (MP4/GIF).", { 
                        left: 50, 
                        top: state.slideHeight - 100, 
                        width: 400, 
                        height: 50
                    });

                    await context.sync();
                });
                
                ui.msg.textContent = `‚úÖ ƒê√£ xu·∫•t th√†nh c√¥ng ${frameCount} frame v√†o Slide! Vui l√≤ng d√πng ch·ª©c nƒÉng "Export to Video" c·ªßa PowerPoint.`;
            
            } catch (error) {
                console.error("L·ªói xu·∫•t Frame:", error);
                ui.msg.textContent = `‚ùå L·ªói xu·∫•t Frame: ${error.message}. Vui l√≤ng ki·ªÉm tra Console log.`;
            } finally {
                // Kh√¥i ph·ª•c tr·∫°ng th√°i m√¥ ph·ªèng
                state.isSimulating = wasSimulating;
                if (state.isSimulating) loop();
                hideLoader();
            }
        }
        
        // --- 9. EVENT LISTENERS KH√ÅC ---
        ui.btnLine.addEventListener('click', () => setMode('line'));
        ui.btnVector.addEventListener('click', () => setMode('vector'));
        ui.btnReset.addEventListener('click', () => {
            state.paths = [];
            state.particles = [];
            // N·∫øu c√≥ canvas ·∫©n (mask) th√¨ c≈©ng x√≥a
            if (maskCanvas.width > 0) {
                 maskCtx.clearRect(0,0,maskCanvas.width, maskCanvas.height);
            }
            ui.msg.textContent = "üóë ƒê√£ x√≥a t·∫•t c·∫£ Path v√† H·∫°t.";
            drawMain();
        });

        // Kh·ªüi t·∫°o Canvas (v·ªõi k√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh)
        resizeCanvas(state.slideWidth, state.slideHeight);
    </script>
</body>
</html>
