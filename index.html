<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XIN CH√ÄO VI·ªÜT NAM - M√¥ Ph·ªèng D√≤ng Ch·∫£y V·∫≠t Li·ªáu 2D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSS cho ch·∫ø ƒë·ªô v·∫Ω */
        .drawing-mode {
            cursor: crosshair !important;
        }
        /* CSS cho ch·∫ø ƒë·ªô ch·ªânh s·ª≠a */
        .edit-mode {
            cursor: pointer !important;
        }
        /* CSS cho ch·∫ø ƒë·ªô k√©o ƒëi·ªÉm neo */
        .grabbing {
            cursor: grabbing !important;
        }
        .flow-container {
            /* Background nh·∫°t ƒë·ªÉ l√†m n·ªïi b·∫≠t canvas */
            background-color: #f7fafc; /* M√†u x√°m nh·∫°t */
            min-height: 100vh;
        }
        /* T√πy ch·ªânh thanh tr∆∞·ª£t ƒë·ªÉ n·ªïi b·∫≠t */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4f46e5; /* M√†u Indigo */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        .canvas-area {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body class="flow-container">

    <div class="bg-indigo-700 py-4 shadow-xl mb-6">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex justify-between items-center">
            <h1 class="text-3xl font-extrabold tracking-wider text-white">
                XIN CH√ÄO VI·ªÜT NAM
            </h1>
            <p class="text-xs text-indigo-300 font-medium">ve</p>
        </div>
    </div>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-10">
        <div class="flex flex-col lg:flex-row gap-6">

            <div class="lg:w-1/4 space-y-6 p-4 bg-white rounded-xl shadow-lg order-2 lg:order-1">
                <p class="text-xl font-bold text-gray-800 border-b pb-2">üõ†Ô∏è Thi·∫øt L·∫≠p</p>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                    <p class="text-lg font-semibold text-gray-700">·∫¢nh & V·∫≠t Li·ªáu</p>
                    <div>
                        <label for="baseImageUpload" class="block text-sm font-medium text-gray-700 mb-1">1. B·∫£n V·∫Ω N·ªÅn (Thi·∫øt b·ªã)</label>
                        <input type="file" id="baseImageUpload" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                    </div>
                    <div>
                        <label for="materialImageUpload" class="block text-sm font-medium text-gray-700 mb-1">2. ·∫¢nh V·∫≠t Li·ªáu (T·ªëi ∆∞u 32x32px)</label>
                        <input type="file" id="materialImageUpload" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                    </div>
                </div>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                    <p class="text-lg font-semibold text-gray-700">T√πy Ch·ªânh</p>
                    
                    <div class="space-y-1">
                        <label for="speedControl" class="block text-sm font-medium text-gray-700">T·ªëc ƒê·ªô: <span id="speedValue" class="text-sm font-bold text-indigo-600 float-right">5</span></label>
                        <input type="range" id="speedControl" min="1" max="15" value="5" step="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div class="space-y-1">
                        <label for="intensityControl" class="block text-sm font-medium text-gray-700">C∆∞·ªùng ƒê·ªô (ƒê·ªô ƒê·∫≠m): <span id="intensityValue" class="text-sm font-bold text-indigo-600 float-right">70%</span></label>
                        <input type="range" id="intensityControl" min="0.0" max="1.0" value="0.7" step="0.05" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <div class="space-y-1">
                        <label for="drawThicknessControl" class="block text-sm font-medium text-gray-700">ƒê·ªô D√†y N√©t V·∫Ω (Path): <span id="drawThicknessValue" class="text-sm font-bold text-indigo-600 float-right">3 px</span></label>
                        <input type="range" id="drawThicknessControl" min="1" max="10" value="3" step="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                    <p class="text-lg font-semibold text-gray-700">Ch·∫ø ƒê·ªô V·∫Ω/Ch·ªânh S·ª≠a</p>
                    <button id="addPathButton" disabled class="w-full py-2 px-3 bg-yellow-500 text-white font-bold rounded-lg shadow-md hover:bg-yellow-600 transition disabled:bg-gray-400 text-sm">
                        + Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)
                    </button>
                    <button id="editPathButton" disabled class="w-full py-2 px-3 bg-pink-500 text-white font-bold rounded-lg shadow-md hover:bg-pink-600 transition disabled:bg-gray-400 text-sm">
                        Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)
                    </button>
                    <button id="addVectorFieldButton" disabled class="w-full py-2 px-3 bg-cyan-600 text-white font-bold rounded-lg shadow-md hover:bg-cyan-700 transition disabled:bg-gray-400 text-sm">
                        + Th√™m V√πng D√≤ng Ch·∫£y (Vector)
                    </button>
                    <div id="vectorDirectionControl" class="flex justify-around space-x-2 mt-2 hidden">
                        <button data-direction="right" class="direction-btn py-1 px-2 bg-gray-200 rounded text-sm hover:bg-gray-300">‚û°Ô∏è Ph·∫£i</button>
                        <button data-direction="left" class="direction-btn py-1 px-2 bg-gray-200 rounded text-sm hover:bg-gray-300">‚¨ÖÔ∏è Tr√°i</button>
                        <button data-direction="up" class="direction-btn py-1 px-2 bg-gray-200 rounded text-sm hover:bg-gray-300">‚¨ÜÔ∏è L√™n</button>
                        <button data-direction="down" class="direction-btn py-1 px-2 bg-gray-200 rounded text-sm hover:bg-gray-300">‚¨áÔ∏è Xu·ªëng</button>
                    </div>

                    <button id="resetPaths" class="w-full py-2 px-3 bg-red-600 text-white font-bold rounded-lg shadow-md hover:bg-red-700 transition text-sm">
                        X√≥a TO√ÄN B·ªò V√πng
                    </button>
                </div>
                
                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                     <p class="text-lg font-semibold text-gray-700">M√¥ Ph·ªèng & Xu·∫•t File</p>
                    <button id="startStopSim" disabled class="w-full py-3 px-6 bg-green-600 text-white font-bold rounded-lg shadow-lg hover:bg-green-700 transition disabled:bg-gray-400 text-sm md:text-base">
                        B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng
                    </button>
                     <button id="generateGif" disabled class="w-full py-3 px-6 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition disabled:bg-gray-400 text-sm md:text-base">
                        T·∫°o T·ªáp GIF (Video 5s)
                    </button>
                </div>
                 <button onclick="openModal('helpModal')" class="w-full py-3 px-6 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700 transition">
                    ? H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng Chi Ti·∫øt
                </button>
            </div>

            <div class="lg:w-3/4 space-y-4 order-1 lg:order-2">
                 <div id="statusMessage" class="text-center text-sm font-semibold text-indigo-700 bg-indigo-100 p-2 rounded-lg">Vui l√≤ng t·∫£i l√™n ·∫£nh n·ªÅn ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>

                <div class="relative canvas-area border-4 border-dashed border-gray-300 rounded-xl overflow-hidden flex justify-center items-center bg-white" style="min-height: 450px; height: 75vh;">
                    <canvas id="simulationCanvas" class="absolute inset-0 w-full h-full"></canvas>
                    <div id="placeholderText" class="absolute text-gray-500 text-xl text-center p-4">
                        1. T·∫£i l√™n B·∫£n V·∫Ω N·ªÅn ƒë·ªÉ b·∫Øt ƒë·∫ßu.
                    </div>
                </div>

                <div id="gifPreviewArea" class="mt-4 text-center hidden p-4 bg-white rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-gray-800">Xem Tr∆∞·ªõc GIF ƒê√£ Xu·∫•t</h2>
                    <img id="gifPreview" class="max-w-full h-auto mx-auto rounded-lg shadow-2xl border-4 border-gray-200" alt="Xem tr∆∞·ªõc ·∫£nh GIF">
                    <a id="gifDownloadLink" download="material_flow_simulation.gif" class="mt-4 inline-block py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition">
                        T·∫£i Xu·ªëng GIF
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <div id="helpModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-11/12 md:w-1/2 max-h-[90vh] overflow-y-auto transform transition-all duration-300 scale-95">
            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng Chi Ti·∫øt (v1.1.1)</h3>
            <ol class="list-decimal list-inside space-y-2 text-gray-600 text-sm">
                <li>**T·∫£i ·∫¢nh N·ªÅn & V·∫≠t Li·ªáu:** T·∫£i l√™n b·∫£n v·∫Ω thi·∫øt b·ªã v√† h√¨nh ·∫£nh v·∫≠t li·ªáu.</li>
                <li>**Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line):** Nh·∫•n n√∫t, **Nh·∫•n v√† Gi·ªØ chu·ªôt** ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒëi t·ª± do. Nh·∫£ chu·ªôt ƒë·ªÉ k·∫øt th√∫c.</li>
                <li>**Ch·ªânh S·ª≠a V√πng Line (Quan tr·ªçng):** Nh·∫•n **"Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)"**. K√©o v√† Th·∫£ c√°c **ƒëi·ªÉm neo (ch·∫•m xanh)** ƒë·ªÉ u·ªën cong, tinh ch·ªânh ƒë∆∞·ªùng ƒëi ch√≠nh x√°c. Nh·∫•n l·∫°i n√∫t ƒë·ªÉ tho√°t.</li>
                <li>**Th√™m V√πng D√≤ng Ch·∫£y (Vector - M·ªöI):** Nh·∫•n n√∫t, sau ƒë√≥ ch·ªçn **H∆∞·ªõng** (Ph·∫£i/Tr√°i/L√™n/Xu·ªëng). **Nh·∫•n v√† Gi·ªØ chu·ªôt** ƒë·ªÉ v·∫Ω **Khu v·ª±c** v·∫≠t li·ªáu s·∫Ω di chuy·ªÉn.</li>
                <li>**T√πy Ch·ªânh C∆∞·ªùng ƒê·ªô (ƒê·ªô ƒê·∫≠m):** Thay ƒë·ªïi thanh tr∆∞·ª£t. N·∫øu ƒë·∫∑t C∆∞·ªùng ƒê·ªô nh·ªè h∆°n 100%, n√©t v·∫Ω m√†u cam s·∫Ω **bi·∫øn m·∫•t ho√†n to√†n** (ƒë√£ s·ª≠a l·ªói) v√† ch·ªâ hi·ªÉn th·ªã c√°c h·∫°t v·∫≠t li·ªáu.</li>
                <li>**Ch·∫°y & Xu·∫•t File:** Nh·∫•n **"B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng"** v√† **"T·∫°o T·ªáp GIF"** (y√™u c·∫ßu file `gif.worker.js`).</li>
            </ol>
            <div class="mt-4 text-xs italic text-gray-500">
                L∆∞u √Ω: Ch·∫ø ƒë·ªô Vector Field kh√¥ng c·∫ßn ƒë∆∞·ªùng ƒëi c·ª• th·ªÉ, m√† m√¥ ph·ªèng s·ª± di chuy·ªÉn ƒë·ªìng b·ªô c·ªßa v·∫≠t li·ªáu trong m·ªôt v√πng k√≠n.
            </div>
            <div class="mt-6 flex justify-end">
                <button onclick="closeModal('helpModal')" class="py-2 px-4 bg-gray-300 text-gray-800 font-semibold rounded-lg hover:bg-gray-400 transition text-sm">ƒê√≥ng</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.js"></script>
    <script>
        // --- C√ÅC THI·∫æT L·∫¨P BAN ƒê·∫¶U ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const baseImageUpload = document.getElementById('baseImageUpload');
        const materialImageUpload = document.getElementById('materialImageUpload');
        const startStopSimButton = document.getElementById('startStopSim');
        const generateGifButton = document.getElementById('generateGif');
        const resetPathsButton = document.getElementById('resetPaths');
        const addPathButton = document.getElementById('addPathButton'); 
        const editPathButton = document.getElementById('editPathButton'); 
        const addVectorFieldButton = document.getElementById('addVectorFieldButton'); 
        const vectorDirectionControl = document.getElementById('vectorDirectionControl'); 
        const directionButtons = document.querySelectorAll('.direction-btn'); 

        const statusMessage = document.getElementById('statusMessage');
        const placeholderText = document.getElementById('placeholderText');
        const speedControl = document.getElementById('speedControl');
        const speedValueSpan = document.getElementById('speedValue');
        const intensityControl = document.getElementById('intensityControl');
        const intensityValueSpan = document.getElementById('intensityValue');
        const drawThicknessControl = document.getElementById('drawThicknessControl');
        const drawThicknessValueSpan = document.getElementById('drawThicknessValue');

        let animationFrameId = null;
        let isSimulating = false;
        let isPathMode = false;     
        let isVectorMode = false;   
        let currentVectorDirection = null; 
        let isDrawing = false;      
        let isEditMode = false;     
        let activeEditPoint = null; 

        let baseImage = new Image();
        let materialImage = new Image();
        let flowPaths = []; 
        let currentDrawingPath = null; 

        let particles = [];
        let simTime = 0;
        const PARTICLE_COUNT_PER_PATH = 150;
        const PARTICLE_SPEED_BASE = 0.0005; 
        let currentParticleSpeed = PARTICLE_SPEED_BASE * 5; 
        const MATERIAL_SIZE = 32; 
        const MIN_PATH_POINTS = 50;
        const NODE_SIZE = 8; 
        const NODE_HIT_RANGE = 12;

        let flowIntensity = 0.7; 
        let currentDrawThickness = 3;

        // --- C√ÅC H√ÄM TI·ªÜN √çCH ---

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function calculatePathDistances(pathObj) {
            if (pathObj.type !== 'line' || pathObj.points.length < 2) return;
            pathObj.distances = [0];
            pathObj.totalLength = 0;
            
            for (let i = 1; i < pathObj.points.length; i++) {
                const dist = distance(pathObj.points[i - 1], pathObj.points[i]);
                pathObj.totalLength += dist;
                pathObj.distances.push(pathObj.totalLength);
            }
            if (pathObj.totalLength === 0 && pathObj.points.length > 0) {
                pathObj.totalLength = 0.001;
            }
        }

        function getPositionOnPath(t, pathObj) {
            if (pathObj.points.length < 2 || pathObj.totalLength === 0) return null;
            t = Math.max(0, Math.min(1, t));
            const targetDistance = t * pathObj.totalLength;
            
            let startIndex = 0;
            for (let i = 1; i < pathObj.distances.length; i++) {
                if (pathObj.distances[i] >= targetDistance) {
                    startIndex = i - 1;
                    break;
                }
            }

            if (t === 1) return pathObj.points[pathObj.points.length - 1];
            const p1 = pathObj.points[startIndex];
            const p2 = pathObj.points[startIndex + 1];

            const dist1 = pathObj.distances[startIndex];
            const segmentLength = pathObj.distances[startIndex + 1] - dist1;
            
            const localT = segmentLength === 0 ? 0 : (targetDistance - dist1) / segmentLength;

            const x = lerp(p1.x, p2.x, localT);
            const y = lerp(p1.y, p2.y, localT);
            return { x, y };
        }

        /**
         * @description Kh·ªüi t·∫°o c√°c h·∫°t cho m·ªôt path c·ª• th·ªÉ.
         */
        function initializeParticles(pathIndex) {
            const path = flowPaths[pathIndex];
            if (path.type === 'line') {
                for (let i = 0; i < PARTICLE_COUNT_PER_PATH; i++) {
                    particles.push({
                        t: Math.random(),
                        pathIndex: pathIndex, 
                        offset: Math.random() * 0.05,
                        size: lerp(0.5, 1.5, Math.random()),
                        type: 'line'
                    });
                }
            } else if (path.type === 'vector') { 
                const minX = Math.min(...path.points.map(p => p.x));
                const maxX = Math.max(...path.points.map(p => p.x));
                const minY = Math.min(...path.points.map(p => p.y));
                const maxY = Math.max(...path.points.map(p => p.y));
                const count = Math.floor(PARTICLE_COUNT_PER_PATH * (path.thickness / 3)); 
                
                for (let i = 0; i < count; i++) {
                     let pX = lerp(minX, maxX, Math.random());
                     let pY = lerp(minY, maxY, Math.random());

                    particles.push({
                        x: pX,
                        y: pY,
                        pathIndex: pathIndex,
                        size: lerp(0.5, 1.5, Math.random()),
                        type: 'vector',
                        offset: Math.random() * 5 
                    });
                }
            }
        }

        /**
         * @description C·∫≠p nh·∫≠t v·ªã tr√≠ c·ªßa t·∫•t c·∫£ c√°c h·∫°t.
         */
        function updateParticles() {
            simTime += 0.01;
            particles.forEach(p => {
                const pathObj = flowPaths[p.pathIndex]; 
                if (!pathObj) return;

                if (p.type === 'line') {
                    p.t += currentParticleSpeed;

                    if (p.t > 1) {
                        p.t = p.t - 1;
                        p.t += (Math.random() * currentParticleSpeed * 5); 
                    }
                } else if (p.type === 'vector') {
                    const speed = currentParticleSpeed * 50; 
                    const bounds = pathObj.points.reduce((acc, point) => ({
                        minX: Math.min(acc.minX, point.x),
                        maxX: Math.max(acc.maxX, point.x),
                        minY: Math.min(acc.minY, point.y),
                        maxY: Math.max(acc.maxY, point.y),
                    }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });

                    let dx = 0;
                    let dy = 0;
                    switch (pathObj.direction) {
                        case 'right': dx = speed; break;
                        case 'left': dx = -speed; break;
                        case 'up': dy = -speed; break;
                        case 'down': dy = speed; break;
                    }

                    p.x += dx + Math.sin(simTime * 10 + p.offset) * 0.5; 
                    p.y += dy + Math.cos(simTime * 10 + p.offset) * 0.5;

                    // Ki·ªÉm tra v√† reset v·ªã tr√≠ 
                    if (p.x < bounds.minX || p.x > bounds.maxX || p.y < bounds.minY || p.y > bounds.maxY) {
                        if (dx > 0) p.x = bounds.minX;
                        else if (dx < 0) p.x = bounds.maxX;
                        
                        if (dy > 0) p.y = bounds.minY;
                        else if (dy < 0) p.y = bounds.maxY;
                        
                        if (dx === 0) p.x = lerp(bounds.minX, bounds.maxX, Math.random());
                        if (dy === 0) p.y = lerp(bounds.minY, bounds.maxY, Math.random());
                    }
                }
            });
        }

        function getClosestNode(x, y) {
            let closest = null;
            let minDist = NODE_HIT_RANGE;

            for (let pIndex = 0; pIndex < flowPaths.length; pIndex++) {
                const path = flowPaths[pIndex];
                if (path.type !== 'line') continue; 
                
                for (let i = 0; i < path.points.length; i += 10) { 
                    const point = path.points[i];
                    const dist = distance(point, { x, y });

                    if (dist < minDist) {
                        minDist = dist;
                        closest = { pathIndex: pIndex, pointIndex: i };
                    }
                }
                
                const lastIndex = path.points.length - 1;
                if (lastIndex % 10 !== 0) {
                    const point = path.points[lastIndex];
                    const dist = distance(point, { x, y });
                     if (dist < minDist) {
                        minDist = dist;
                        closest = { pathIndex: pIndex, pointIndex: lastIndex };
                    }
                }
            }
            return closest;
        }


        // --- H√ÄM V·∫º CH√çNH ---

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω h√¨nh n·ªÅn
            let drawArea = { x: 0, y: 0, w: canvas.width, h: canvas.height, offsetX: 0, offsetY: 0 };
            if (baseImage.complete && baseImage.naturalWidth !== 0) {
                const aspectRatio = baseImage.naturalWidth / baseImage.naturalHeight;
                if (canvas.width / canvas.height > aspectRatio) {
                    drawArea.h = canvas.height;
                    drawArea.w = drawArea.h * aspectRatio;
                    drawArea.offsetX = (canvas.width - drawArea.w) / 2;
                } else {
                    drawArea.w = canvas.width;
                    drawArea.h = drawArea.w / aspectRatio;
                    drawArea.offsetY = (canvas.height - drawArea.h) / 2;
                }

                ctx.drawImage(baseImage, drawArea.offsetX, drawArea.offsetY, drawArea.w, drawArea.h);
                placeholderText.classList.add('hidden');
                addPathButton.disabled = false;
                addVectorFieldButton.disabled = false;
                editPathButton.disabled = flowPaths.filter(p => p.type === 'line').length === 0;
            } else {
                placeholderText.classList.remove('hidden');
                addPathButton.disabled = true;
                addVectorFieldButton.disabled = true;
                editPathButton.disabled = true;
                return;
            }

            // 2. V·∫º T·∫§T C·∫¢ C√ÅC ƒê∆Ø·ªúNG ƒêI ƒê√É ƒê·ªäNH NGHƒ®A (ƒê∆Ø·ªúNG THAM CHI·∫æU)
            flowPaths.forEach(path => {
                if (path.type === 'line') {
                    // S·ª¨A L·ªñI L√ÄM M·ªú: Ch·ªâ v·∫Ω Line Path n·∫øu Opacity = 1.0 (flowIntensity)
                    if (path.points.length > 1 && flowIntensity === 1.0) { 
                        ctx.strokeStyle = '#f97316'; // M√†u cam
                        ctx.lineWidth = path.thickness || 3; 
                        ctx.setLineDash([]); 

                        ctx.beginPath();
                        ctx.moveTo(path.points[0].x, path.points[0].y);
                        
                        for (let i = 1; i < path.points.length; i++) {
                            ctx.lineTo(path.points[i].x, path.points[i].y);
                        }
                        ctx.stroke();
                    }

                    // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô ch·ªânh s·ª≠a, v·∫Ω c√°c ƒëi·ªÉm neo cho Line Path
                    if (isEditMode) {
                        const pointsToDraw = [];
                        for (let i = 0; i < path.points.length; i += 10) {
                            pointsToDraw.push({point: path.points[i], index: i});
                        }
                        const lastIndex = path.points.length - 1;
                        if (lastIndex % 10 !== 0) {
                             pointsToDraw.push({point: path.points[lastIndex], index: lastIndex});
                        }

                        pointsToDraw.forEach(({point, index}) => {
                            ctx.fillStyle = (activeEditPoint && activeEditPoint.pathIndex === flowPaths.indexOf(path) && activeEditPoint.pointIndex === index) ? '#ef4444' : '#10b981'; 
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, NODE_SIZE / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        });
                    }
                } else if (path.type === 'vector') {
                    // V·∫Ω khung c·ªßa Vector Field Path
                    if (path.points.length >= 2) {
                        const minX = Math.min(...path.points.map(p => p.x));
                        const maxX = Math.max(...path.points.map(p => p.x));
                        const minY = Math.min(...path.points.map(p => p.y));
                        const maxY = Math.max(...path.points.map(p => p.y));

                        const w = maxX - minX;
                        const h = maxY - minY;

                        ctx.strokeStyle = '#06b6d4'; 
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]); 
                        ctx.strokeRect(minX, minY, w, h);
                        ctx.setLineDash([]); 

                        ctx.fillStyle = '#06b6d4';
                        ctx.font = '18px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        let arrow = '';
                        switch (path.direction) {
                            case 'right': arrow = '‚û°Ô∏è'; break;
                            case 'left': arrow = '‚¨ÖÔ∏è'; break;
                            case 'up': arrow = '‚¨ÜÔ∏è'; break;
                            case 'down': arrow = '‚¨áÔ∏è'; break;
                        }
                        ctx.fillText(arrow, minX + w / 2, minY + h / 2);
                    }
                }
            });

            // 3. V·∫º H·ªÜ TH·ªêNG H·∫†T V√Ä √ÅP D·ª§NG C∆Ø·ªúNG ƒê·ªò (OPACITY)
            if (isSimulating) {
                ctx.globalAlpha = flowIntensity;
                particles.forEach(p => {
                    const pathObj = flowPaths[p.pathIndex]; 
                    if (!pathObj) return;

                    let pos = { x: 0, y: 0 };
                    if (p.type === 'line') {
                        if (pathObj.points.length < MIN_PATH_POINTS) return;
                        pos = getPositionOnPath(p.t, pathObj);
                    } else if (p.type === 'vector') {
                        pos = { x: p.x, y: p.y };
                    }
                    
                    if (pos) {
                        const size = MATERIAL_SIZE * p.size;
                        const halfSize = size / 2;
                        
                        const noiseX = p.type === 'line' ? Math.sin(p.t * 50 + simTime) * 3 * p.offset : 0;
                        const noiseY = p.type === 'line' ? Math.cos(p.t * 30 + simTime) * 3 * p.offset : 0;
                        
                        const x = pos.x - halfSize + noiseX;
                        const y = pos.y - halfSize + noiseY;

                        if (materialImage.complete && materialImage.naturalWidth !== 0) {
                            ctx.drawImage(materialImage, x, y, size, size);
                        } else {
                            ctx.fillStyle = '#facc15'; 
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, halfSize * 0.7, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                ctx.globalAlpha = 1.0; 
            }

            // 4. Th√¥ng b√°o tr·∫°ng th√°i v·∫Ω
            if (isDrawing && currentDrawingPath) {
                const pointsCount = currentDrawingPath.points.length;
                if (pointsCount > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
                    ctx.fillStyle = '#374151';
                    ctx.font = '14px Inter';
                    ctx.textAlign = 'center';
                    const typeText = currentDrawingPath.type === 'line' ? 'ƒê∆∞·ªùng Line' : 'V√πng Vector';
                    if (pointsCount < MIN_PATH_POINTS && currentDrawingPath.type === 'line') {
                        ctx.fillText(`ƒêang v·∫Ω V√πng ${flowPaths.length} (${typeText}). C·∫ßn ${MIN_PATH_POINTS - pointsCount} ƒëi·ªÉm n·ªØa.`, canvas.width / 2, canvas.height - 10);
                    } else {
                         ctx.fillText(`ƒê√£ c√≥ ${pointsCount} ƒëi·ªÉm. Nh·∫£ chu·ªôt/ng√≥n tay ƒë·ªÉ x√°c nh·∫≠n V√πng M√¥ Ph·ªèng (${typeText}).`, canvas.width / 2, canvas.height - 10);
                    }
                }
            }
        }

        function animate() {
            if (isSimulating) {
                updateParticles();
            }
            draw();
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- X·ª¨ L√ù S·ª∞ KI·ªÜN CHU·ªòT/C·∫¢M ·ª®NG ---

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;
            return { x, y };
        }

        // --- MOUSE DOWN / TOUCH START (ƒê√É FIX L·ªñI UPLOAD) ---
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', (e) => {
            // QUAN TR·ªåNG: Ch·ªâ ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh (ngƒÉn m·ªü input file) n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô t∆∞∆°ng t√°c
            if (isPathMode || isVectorMode || isEditMode) {
                e.preventDefault(); 
            }
            handleStart(e);
        }, { passive: false });
        function handleStart(e) {
            const { x, y } = getCoords(e);
            
            if (isPathMode && !isDrawing) {
                isDrawing = true;
                currentDrawingPath = {
                    points: [],
                    distances: [],
                    totalLength: 0,
                    thickness: currentDrawThickness,
                    type: 'line'
                };
                flowPaths.push(currentDrawingPath);
                currentDrawingPath.points.push({ x, y });
                draw();
            } 
            else if (isVectorMode && currentVectorDirection && !isDrawing) {
                isDrawing = true;
                currentDrawingPath = {
                    points: [{ x, y }], 
                    direction: currentVectorDirection,
                    type: 'vector',
                    thickness: 1 
                };
                flowPaths.push(currentDrawingPath);
                draw();
            }
            else if (isEditMode && flowPaths.length > 0) {
                const node = getClosestNode(x, y);
                if (node) {
                    activeEditPoint = node;
                    canvas.classList.add('grabbing');
                    statusMessage.textContent = `ƒêang k√©o ƒëi·ªÉm neo V√πng ${node.pathIndex + 1}...`;
                }
            }
        }

        // --- MOUSE MOVE / TOUCH MOVE (ƒê√É FIX L·ªñI UPLOAD) ---
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('touchmove', (e) => {
            // QUAN TR·ªåNG: Ch·ªâ ch·∫∑n h√†nh vi cu·ªôn m·∫∑c ƒë·ªãnh n·∫øu ƒëang v·∫Ω ho·∫∑c ch·ªânh s·ª≠a
            if (isDrawing || isEditMode) {
                e.preventDefault();
            }
            handleMove(e);
        }, { passive: false });
        function handleMove(e) {
            const { x, y } = getCoords(e);
            
            if (isDrawing && currentDrawingPath) {
                const lastPoint = currentDrawingPath.points[currentDrawingPath.points.length - 1];
                
                if (!lastPoint || distance(lastPoint, { x, y }) > 1) { 
                    if (currentDrawingPath.type === 'line') {
                        currentDrawingPath.points.push({ x, y });
                    } 
                    else if (currentDrawingPath.type === 'vector') {
                         if (currentDrawingPath.points.length > 1) {
                             currentDrawingPath.points.pop();
                         }
                         currentDrawingPath.points.push({ x, y });
                    }
                    draw();
                }
            }
            else if (isEditMode && activeEditPoint) {
                const path = flowPaths[activeEditPoint.pathIndex];
                if (path.type !== 'line') return; 
                
                const index = activeEditPoint.pointIndex;
                
                path.points[index].x = x;
                path.points[index].y = y;
                
                const range = 10;
                for (let i = index - range; i <= index + range; i++) {
                    if (i >= 0 && i < path.points.length && i !== index) {
                        const weight = 1 - (Math.abs(i - index) / range);
                        
                        const dx = x - path.points[i].x;
                        const dy = y - path.points[i].y;
                        
                        path.points[i].x += dx * weight * 0.05;
                        path.points[i].y += dy * weight * 0.05;
                    }
                }
                
                calculatePathDistances(path);
                draw();
            }
        }

        // --- MOUSE UP / TOUCH END ---
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchend', handleEnd);

        function handleEnd() {
            if (isDrawing && currentDrawingPath) {
                isDrawing = false;
                
                if (currentDrawingPath.type === 'line') {
                    isPathMode = false;
                    canvas.classList.remove('drawing-mode');
                    
                    calculatePathDistances(currentDrawingPath);
                    
                    if (currentDrawingPath.points.length >= MIN_PATH_POINTS) {
                        initializeParticles(flowPaths.length - 1);
                        statusMessage.textContent = `ƒê√£ x√°c nh·∫≠n V√πng ${flowPaths.length} (Line). Nh·∫•n 'Ch·ªânh s·ª≠a' ƒë·ªÉ tinh ch·ªânh ƒë∆∞·ªùng ƒëi.`;
                    } else {
                        flowPaths.pop();
                        statusMessage.textContent = `V√πng Line kh√¥ng h·ª£p l·ªá (√≠t h∆°n ${MIN_PATH_POINTS} ƒëi·ªÉm). H√£y v·∫Ω l·∫°i.`;
                    }
                } 
                else if (currentDrawingPath.type === 'vector') {
                    isVectorMode = false;
                    currentVectorDirection = null;
                    vectorDirectionControl.classList.add('hidden');
                    canvas.classList.remove('drawing-mode');

                    if (currentDrawingPath.points.length >= 2) {
                        initializeParticles(flowPaths.length - 1);
                        statusMessage.textContent = `ƒê√£ x√°c nh·∫≠n V√πng ${flowPaths.length} (Vector). H∆∞·ªõng: ${currentDrawingPath.direction}.`;
                    } else {
                        flowPaths.pop();
                        statusMessage.textContent = `V√πng Vector kh√¥ng h·ª£p l·ªá. H√£y nh·∫•n v√† gi·ªØ ƒë·ªÉ v·∫Ω m·ªôt khu v·ª±c.`;
                    }
                }

                currentDrawingPath = null;
                updateButtonStates();
            }
            
            else if (isEditMode && activeEditPoint) {
                if (flowPaths[activeEditPoint.pathIndex].type === 'line') {
                    calculatePathDistances(flowPaths[activeEditPoint.pathIndex]);
                }
                activeEditPoint = null;
                canvas.classList.remove('grabbing');
                statusMessage.textContent = `ƒê√£ l∆∞u ch·ªânh s·ª≠a. B·∫°n c√≥ th·ªÉ k√©o ƒëi·ªÉm kh√°c ho·∫∑c tho√°t ch·∫ø ƒë·ªô.`;
                draw();
            }
        }

        // --- QU·∫¢N L√ù TR·∫†NG TH√ÅI N√öT ---

        function updateButtonStates() {
            const hasPaths = flowPaths.length > 0;
            const hasLinePaths = flowPaths.filter(p => p.type === 'line').length > 0;

            startStopSimButton.disabled = !hasPaths || isPathMode || isVectorMode || isEditMode;
            generateGifButton.disabled = !hasPaths || isPathMode || isVectorMode || isEditMode;
            
            addPathButton.disabled = baseImage.naturalWidth === 0 || isVectorMode || isEditMode;
            addVectorFieldButton.disabled = baseImage.naturalWidth === 0 || isPathMode || isEditMode;
            editPathButton.disabled = !hasLinePaths || isPathMode || isVectorMode;

            if (isSimulating) {
                addPathButton.disabled = true;
                addVectorFieldButton.disabled = true;
                editPathButton.disabled = true;
            }
        }

        /**
         * @description Tho√°t kh·ªèi m·ªçi ch·∫ø ƒë·ªô v·∫Ω/ch·ªânh s·ª≠a v√† chu·∫©n b·ªã cho thao t√°c kh√°c.
         */
        function exitAllModes() {
            isSimulating = false;
            isPathMode = false;
            isVectorMode = false;
            isDrawing = false;
            isEditMode = false;
            activeEditPoint = null;
            currentVectorDirection = null;
            vectorDirectionControl.classList.add('hidden');

            canvas.classList.remove('drawing-mode', 'edit-mode', 'grabbing');
            startStopSimButton.textContent = "B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng";
            addPathButton.textContent = "+ Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)";
            addVectorFieldButton.textContent = "+ Th√™m V√πng D√≤ng Ch·∫£y (Vector)";
            editPathButton.textContent = "Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)";
        }

        /**
         * @description B·∫≠t/T·∫Øt ch·∫ø ƒë·ªô V·∫Ω Line Path.
         */
        function toggleDrawingMode() {
            if (baseImage.naturalWidth === 0) {
                statusMessage.textContent = "Vui l√≤ng t·∫£i l√™n B·∫£n V·∫Ω N·ªÅn tr∆∞·ªõc.";
                return;
            }
            
            exitAllModes();
            isPathMode = !isPathMode; 

            if (isPathMode) {
                canvas.classList.add('drawing-mode');
                statusMessage.textContent = `CHU·∫®N B·ªä V·∫º LINE PATH ${flowPaths.filter(p => p.type === 'line').length + 1}. Nh·∫•n v√† Gi·ªØ chu·ªôt ƒë·ªÉ b·∫Øt ƒë·∫ßu.`;
                addPathButton.textContent = "H·ªßy V·∫Ω Line";
            } else {
                statusMessage.textContent = "ƒê√£ h·ªßy v·∫Ω Line. Nh·∫•n 'Th√™m V√πng D√≤ng Ch·∫£y' ƒë·ªÉ ti·∫øp t·ª•c.";
            }
            updateButtonStates();
            draw();
        }

        /**
         * @description B·∫≠t/T·∫Øt ch·∫ø ƒë·ªô V·∫Ω Vector Field.
         */
        function toggleVectorMode() {
            if (baseImage.naturalWidth === 0) {
                statusMessage.textContent = "Vui l√≤ng t·∫£i l√™n B·∫£n V·∫Ω N·ªÅn tr∆∞·ªõc.";
                return;
            }

            exitAllModes();
            isVectorMode = !isVectorMode;

            if (isVectorMode) {
                vectorDirectionControl.classList.remove('hidden');
                statusMessage.textContent = "CH·ªåN H∆Ø·ªöNG D√íNG CH·∫¢Y. Sau ƒë√≥ Nh·∫•n & Gi·ªØ chu·ªôt ƒë·ªÉ v·∫Ω khu v·ª±c.";
                addVectorFieldButton.textContent = "H·ªßy V·∫Ω Vector";
            } else {
                vectorDirectionControl.classList.add('hidden');
                statusMessage.textContent = "ƒê√£ h·ªßy v·∫Ω Vector. Nh·∫•n 'Th√™m V√πng D√≤ng Ch·∫£y' ƒë·ªÉ ti·∫øp t·ª•c.";
            }
            updateButtonStates();
            draw();
        }

        /**
         * @description B·∫≠t/T·∫Øt ch·∫ø ƒë·ªô Ch·ªânh s·ª≠a Line Path.
         */
        function toggleEditMode() {
            if (flowPaths.filter(p => p.type === 'line').length === 0) {
                statusMessage.textContent = "Ch∆∞a c√≥ v√πng Line n√†o ƒë·ªÉ ch·ªânh s·ª≠a.";
                return;
            }

            exitAllModes();
            isEditMode = !isEditMode;

            if (isEditMode) {
                canvas.classList.add('edit-mode');
                editPathButton.textContent = "Xong (Tho√°t Ch·ªânh S·ª≠a)";
                statusMessage.textContent = "ƒê√£ v√†o ch·∫ø ƒë·ªô CH·ªàNH S·ª¨A ƒêI·ªÇM (Line). Nh·∫•n v√†o c√°c ch·∫•m xanh ƒë·ªÉ k√©o v√† tinh ch·ªânh ƒë∆∞·ªùng ƒëi.";
            } else {
                statusMessage.textContent = "ƒê√£ tho√°t ch·∫ø ƒë·ªô ch·ªânh s·ª≠a. B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu m√¥ ph·ªèng.";
            }
            updateButtonStates();
            draw();
        }

        // --- G√ÅN S·ª∞ KI·ªÜN N√öT ---
        addPathButton.addEventListener('click', toggleDrawingMode); 
        editPathButton.addEventListener('click', toggleEditMode); 
        addVectorFieldButton.addEventListener('click', toggleVectorMode);
        
        directionButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                directionButtons.forEach(b => b.classList.remove('bg-indigo-200'));
                e.target.classList.add('bg-indigo-200');
                
                currentVectorDirection = e.target.getAttribute('data-direction');
                canvas.classList.add('drawing-mode');
                statusMessage.textContent = `ƒê√É CH·ªåN H∆Ø·ªöNG ${e.target.textContent}. Nh·∫•n v√† Gi·ªØ chu·ªôt ƒë·ªÉ v·∫Ω khu v·ª±c m√¥ ph·ªèng.`;
            });
        });

        resetPathsButton.addEventListener('click', () => {
            flowPaths = [];
            particles = [];
            exitAllModes();
            updateButtonStates();
            statusMessage.textContent = "ƒê√£ x√≥a to√†n b·ªô v√πng v·∫Ω. H√£y th√™m v√πng m·ªõi.";
            draw();
        });

        startStopSimButton.addEventListener('click', () => {
            if (flowPaths.length === 0) {
                statusMessage.textContent = "Vui l√≤ng v·∫Ω √≠t nh·∫•t m·ªôt v√πng m√¥ ph·ªèng h·ª£p l·ªá.";
                return;
            }
            
            exitAllModes();

            isSimulating = !isSimulating;
            startStopSimButton.textContent = isSimulating ? "D·ª™NG M√¥ Ph·ªèng" : "TI·∫æP T·ª§C M√¥ Ph·ªèng";
            statusMessage.textContent = isSimulating ? "ƒêang ch·∫°y m√¥ ph·ªèng..." : "ƒê√£ d·ª´ng m√¥ ph·ªèng.";
            updateButtonStates();
        });

        // --- X·ª¨ L√ù S·ª∞ KI·ªÜN T·∫¢I ·∫¢NH V√Ä THANH TR∆Ø·ª¢T ---
        baseImageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    baseImage.onload = () => {
                        resizeCanvas();
                        updateButtonStates();
                        statusMessage.textContent = "ƒê√£ t·∫£i ·∫£nh n·ªÅn. Nh·∫•n '+ Th√™m V√πng D√≤ng Ch·∫£y' ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒëi.";
                    };
                    baseImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        materialImageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    materialImage.src = event.target.result;
                    draw(); 
                };
                reader.readAsDataURL(file);
            }
        });

        speedControl.addEventListener('input', (e) => {
            const speedMultiplier = parseInt(e.target.value);
            speedValueSpan.textContent = speedMultiplier;
            currentParticleSpeed = PARTICLE_SPEED_BASE * speedMultiplier; 
        });

        intensityControl.addEventListener('input', (e) => {
            flowIntensity = parseFloat(e.target.value);
            intensityValueSpan.textContent = `${Math.round(flowIntensity * 100)}%`;
            draw(); 
        });

        drawThicknessControl.addEventListener('input', (e) => {
            currentDrawThickness = parseInt(e.target.value);
            drawThicknessValueSpan.textContent = `${currentDrawThickness} px`;
        });

        intensityControl.dispatchEvent(new Event('input'));
        speedControl.dispatchEvent(new Event('input')); 

        // 6. T·∫°o GIF (ƒê√É S·ª¨A L·ªñI ƒê∆Ø·ªúNG D·∫™N workerScript cho GitHub Pages)
        generateGifButton.addEventListener('click', () => {
            if (flowPaths.length === 0) {
                statusMessage.textContent = "Vui l√≤ng v·∫Ω √≠t nh·∫•t m·ªôt v√πng m√¥ ph·ªèng h·ª£p l·ªá ƒë·ªÉ t·∫°o GIF.";
                return;
            }

            exitAllModes();
            startStopSimButton.textContent = "B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng";
            
            statusMessage.textContent = "ƒêang t·∫°o GIF... Vui l√≤ng ch·ªù (qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t 15-30 gi√¢y).";
            generateGifButton.disabled = true;

            // ƒê√É FIX: S·ª≠ d·ª•ng ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi GitHub Pages
            const gif = new GIF({
                workers: 2,
                quality: 10, 
                width: canvas.width,
                height: canvas.height,
                workerScript: './gif.worker.js' 
            });

            const DURATION = 5000; 
            const FPS = 30;
            const FRAMES_TO_CAPTURE = Math.floor((DURATION / 1000) * FPS);
            const FRAME_DELAY = 1000 / FPS; 

            particles.forEach(p => {
                if (p.type === 'line') p.t = Math.random();
            });
            simTime = 0;
            let frameCount = 0;
            
            function captureFrame() {
                if (frameCount < FRAMES_TO_CAPTURE) {
                    updateParticles();
                    draw();
                    
                    gif.addFrame(ctx, { delay: FRAME_DELAY, copy: true });
                    frameCount++;
                    
                    setTimeout(captureFrame, 0);
                } else {
                    gif.render();
                }
            }

            captureFrame();
            gif.on('finished', (blob) => {
                const url = URL.createObjectURL(blob);
                gifPreview.src = url;
                gifDownloadLink.href = url;
                document.getElementById('gifPreviewArea').classList.remove('hidden');
                statusMessage.textContent = "T·∫°o GIF ho√†n t·∫•t! T·∫£i xu·ªëng ho·∫∑c xem tr∆∞·ªõc.";
                generateGifButton.disabled = false;
            });

            gif.on('error', (error) => {
                console.error("L·ªói khi t·∫°o GIF:", error);
                statusMessage.textContent = "L·ªói khi t·∫°o GIF. Vui l√≤ng ki·ªÉm tra console.";
                generateGifButton.disabled = false;
            });
        });

        // --- H√ÄM MODAL H∆Ø·ªöNG D·∫™N ---
        function openModal(id) {
            const modal = document.getElementById(id);
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-95');
            modal.querySelector('div').classList.add('scale-100');
        }

        function closeModal(id) {
            const modal = document.getElementById(id);
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            setTimeout(() => {
                modal.classList.add('opacity-0', 'pointer-events-none');
            }, 300);
        }

        window.openModal = openModal;
        window.closeModal = closeModal;

        // --- KH·ªûI CH·∫†Y ---
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); 
        animate();
        updateButtonStates();
    </script>
</body>
</html>
