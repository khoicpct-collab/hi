<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XIN CH√ÄO - M√¥ Ph·ªèng D√≤ng Ch·∫£y V·∫≠t Li·ªáu 2D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSS cho ch·∫ø ƒë·ªô v·∫Ω */
        .drawing-mode {
            cursor: crosshair !important;
        }
        /* CSS cho ch·∫ø ƒë·ªô ch·ªânh s·ª≠a */
        .edit-mode {
            cursor: pointer !important;
        }
        /* CSS cho ch·∫ø ƒë·ªô k√©o ƒëi·ªÉm neo */
        .grabbing {
            cursor: grabbing !important;
        }
        .flow-container {
            /* Background nh·∫°t ƒë·ªÉ l√†m n·ªïi b·∫≠t canvas */
            background-color: #f7fafc; /* M√†u x√°m nh·∫°t */
            min-height: 100vh;
        }
        /* T√πy ch·ªânh thanh tr∆∞·ª£t ƒë·ªÉ n·ªïi b·∫≠t */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4f46e5; /* M√†u Indigo */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        .canvas-area {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        /* 1. CSS CHO HEADER M·ªöI */
        .header-background {
            /* Thay ƒë·ªïi ·∫£nh n·ªÅn theo y√™u c·∫ßu (ƒê·∫∑t t√™n file c·ªßa b·∫°n v√†o ƒë√¢y) */
            background-image: url('wheat-640960_1280.jpg'); 
            background-size: cover;
            background-position: center bottom; /* T·∫≠p trung v√†o l√∫a m√¨ */
            background-repeat: no-repeat;
            min-height: 250px; /* TƒÉng chi·ªÅu cao header ƒë·ªÉ th·∫•y r√µ background */
            display: flex;
            align-items: center;
            position: relative;
            padding-top: 4rem; /* ƒê·ªÉ ch·ªØ kh√¥ng b·ªã d√≠nh v√†o c·∫°nh tr√™n */
            padding-bottom: 4rem;
        }

        /* 2. HI·ªÜU ·ª®NG TEXT S·∫∂C S·ª† */
        .colorful-text {
            font-family: 'Arial Black', Gadget, sans-serif;
            font-size: 4rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
            /* √Åp d·ª•ng gradient c·∫ßu v·ªìng */
            background: linear-gradient(90deg, #ff0000, #ff8c00, #ffff00, #00ff00, #00bfff, #0000ff, #8a2be2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: moveGradient 10s linear infinite;
            display: inline-block;
        }
        
        @keyframes moveGradient {
            to {
                background-position: 200% center;
            }
        }
        
        /* L·ªõp ph·ªß m·ªù ƒë·ªÉ ch·ªØ d·ªÖ ƒë·ªçc h∆°n */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3); /* L·ªõp ph·ªß t·ªëi m·ªù */
            backdrop-filter: blur(1px); /* T√πy ch·ªçn l√†m m·ªù nh·∫π */
        }
    </style>
</head>
<body class="flow-container">

    <div class="header-background shadow-2xl mb-6">
        <div class="overlay"></div> 
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex flex-col items-start relative z-10 w-full">
            <h1 class="colorful-text">
                XIN CH√ÄO
            </h1>
            <p class="text-xl text-white font-medium italic mt-2 tracking-wider">M√¥ Ph·ªèng D√≤ng Ch·∫£y V·∫≠t Li·ªáu 2D</p>
            <p class="text-sm text-white font-light mt-1">v1.3 - T·ªëi ∆∞u c√¥ng c·ª• v·∫Ω</p>
        </div>
    </div>
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-10">
        <div class="flex flex-col lg:flex-row gap-6">

            <div class="lg:w-1/4 space-y-6 p-4 bg-white rounded-xl shadow-lg order-2 lg:order-1">
                <p class="text-xl font-bold text-gray-800 border-b pb-2">üõ†Ô∏è Thi·∫øt L·∫≠p</p>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                    <p class="text-lg font-semibold text-gray-700">·∫¢nh & V·∫≠t Li·ªáu</p>
                    <div>
                        <label for="baseImageUpload" class="block text-sm font-medium text-gray-700 mb-1">1. B·∫£n V·∫Ω N·ªÅn (Thi·∫øt b·ªã)</label>
                        <input type="file" id="baseImageUpload" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                    </div>
                    <div>
                        <label for="materialImageUpload" class="block text-sm font-medium text-gray-700 mb-1">2. ·∫¢nh V·∫≠t Li·ªáu (T·ªëi ∆∞u 32x32px)</label>
                        <input type="file" id="materialImageUpload" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                    </div>
                </div>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                    <p class="text-lg font-semibold text-gray-700">T√πy Ch·ªânh</p>
                    
                    <div class="space-y-1">
                        <label for="speedControl" class="block text-sm font-medium text-gray-700">T·ªëc ƒê·ªô: <span id="speedValue" class="text-sm font-bold text-indigo-600 float-right">5</span></label>
                        <input type="range" id="speedControl" min="1" max="15" value="5" step="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div class="space-y-1">
                        <label for="intensityControl" class="block text-sm font-medium text-gray-700">C∆∞·ªùng ƒê·ªô (ƒê·ªô ƒê·∫≠m): <span id="intensityValue" class="text-sm font-bold text-indigo-600 float-right">70%</span></label>
                        <input type="range" id="intensityControl" min="0.0" max="1.0" value="0.7" step="0.05" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <div class="space-y-1">
                        <label for="drawThicknessControl" class="block text-sm font-medium text-gray-700">ƒê·ªô D√†y N√©t V·∫Ω (Path): <span id="drawThicknessValue" class="text-sm font-bold text-indigo-600 float-right">3 px</span></label>
                        <input type="range" id="drawThicknessControl" min="1" max="10" value="3" step="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                    <p class="text-lg font-semibold text-gray-700">Ch·∫ø ƒê·ªô V·∫Ω/Ch·ªânh S·ª≠a</p>
                    <button id="addPathButton" disabled class="w-full py-2 px-3 bg-yellow-500 text-white font-bold rounded-lg shadow-md hover:bg-yellow-600 transition disabled:bg-gray-400 text-sm">
                        + Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)
                    </button>
                    <button id="editPathButton" disabled class="w-full py-2 px-3 bg-pink-500 text-white font-bold rounded-lg shadow-md hover:bg-pink-600 transition disabled:bg-gray-400 text-sm">
                        Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)
                    </button>
                    <button id="addVectorFieldButton" disabled class="w-full py-2 px-3 bg-cyan-600 text-white font-bold rounded-lg shadow-md hover:bg-cyan-700 transition disabled:bg-gray-400 text-sm">
                        + Th√™m V√πng D√≤ng Ch·∫£y (Vector)
                    </button>
                    
                    <button id="resetPaths" class="w-full py-2 px-3 bg-red-600 text-white font-bold rounded-lg shadow-md hover:bg-red-700 transition text-sm">
                        X√≥a TO√ÄN B·ªò V√πng
                    </button>
                </div>
                
                <div class="p-4 border rounded-lg bg-gray-50 space-y-3">
                      <p class="text-lg font-semibold text-gray-700">M√¥ Ph·ªèng & Xu·∫•t File</p>
                    <button id="startStopSim" disabled class="w-full py-3 px-6 bg-green-600 text-white font-bold rounded-lg shadow-lg hover:bg-green-700 transition disabled:bg-gray-400 text-sm md:text-base">
                        B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng
                    </button>
                      <button id="generateGif" disabled class="w-full py-3 px-6 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition disabled:bg-gray-400 text-sm md:text-base">
                        T·∫°o T·ªáp GIF (Video 5s)
                    </button>
                </div>
                 <button onclick="openModal('helpModal')" class="w-full py-3 px-6 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700 transition">
                    ? H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng Chi Ti·∫øt
                </button>
            </div>

            <div class="lg:w-3/4 space-y-4 order-1 lg:order-2">
                 <div id="statusMessage" class="text-center text-sm font-semibold text-indigo-700 bg-indigo-100 p-2 rounded-lg">Vui l√≤ng t·∫£i l√™n ·∫£nh n·ªÅn ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>

                <div class="relative canvas-area border-4 border-dashed border-gray-300 rounded-xl overflow-hidden flex justify-center items-center bg-white" style="min-height: 450px; height: 75vh;">
                    <canvas id="simulationCanvas" class="absolute inset-0 w-full h-full"></canvas>
                    <div id="placeholderText" class="absolute text-gray-500 text-xl text-center p-4">
                        1. T·∫£i l√™n B·∫£n V·∫Ω N·ªÅn ƒë·ªÉ b·∫Øt ƒë·∫ßu.
                    </div>
                </div>

                <div id="gifPreviewArea" class="mt-4 text-center hidden p-4 bg-white rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-gray-800">Xem Tr∆∞·ªõc GIF ƒê√£ Xu·∫•t</h2>
                    <img id="gifPreview" class="max-w-full h-auto mx-auto rounded-lg shadow-2xl border-4 border-gray-200" alt="Xem tr∆∞·ªõc ·∫£nh GIF">
                    <a id="gifDownloadLink" download="material_flow_simulation.gif" class="mt-4 inline-block py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition">
                        T·∫£i Xu·ªëng GIF
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <div id="helpModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-11/12 md:w-1/2 max-h-[90vh] overflow-y-auto transform transition-all duration-300 scale-95">
            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng Chi Ti·∫øt (v1.3 - T·ªëi ∆∞u)</h3>
            <ol class="list-decimal list-inside space-y-2 text-gray-600 text-sm">
                <li>**T·∫£i ·∫¢nh N·ªÅn & V·∫≠t Li·ªáu:** T·∫£i l√™n b·∫£n v·∫Ω thi·∫øt b·ªã v√† h√¨nh ·∫£nh v·∫≠t li·ªáu.</li>
                <li>**Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line - Pen/Brush):** Nh·∫•n n√∫t, **Nh·∫•n v√† Gi·ªØ chu·ªôt** ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒëi t·ª± do. Nh·∫£ chu·ªôt ƒë·ªÉ k·∫øt th√∫c. V·∫≠t li·ªáu s·∫Ω di chuy·ªÉn theo ƒë∆∞·ªùng n√†y.</li>
                <li>**Ch·ªânh S·ª≠a V√πng Line (Quan tr·ªçng):** Nh·∫•n **"Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)"**. K√©o v√† Th·∫£ c√°c **ƒëi·ªÉm neo (ch·∫•m xanh)** ƒë·ªÉ u·ªën cong, tinh ch·ªânh ƒë∆∞·ªùng ƒëi ch√≠nh x√°c. Nh·∫•n l·∫°i n√∫t ƒë·ªÉ tho√°t.</li>
                <li>**Th√™m V√πng D√≤ng Ch·∫£y (Vector - Khu V·ª±c):** Nh·∫•n n√∫t, sau ƒë√≥ **Nh·∫•n v√† K√©o chu·ªôt** ƒë·ªÉ v·∫Ω Khu v·ª±c h√¨nh ch·ªØ nh·∫≠t. **T·∫•t c·∫£ v·∫≠t li·ªáu trong v√πng n√†y s·∫Ω di chuy·ªÉn ƒë·ªìng b·ªô c√πng m·ªôt h∆∞·ªõng** (h∆∞·ªõng ƒë∆∞·ª£c x√°c ƒë·ªãnh theo chi·ªÅu k√©o chu·ªôt).</li>
                <li>**T√πy Ch·ªânh C∆∞·ªùng ƒê·ªô (ƒê·ªô ƒê·∫≠m):** Thanh tr∆∞·ª£t < 100% s·∫Ω l√†m ·∫©n ƒë∆∞·ªùng tham chi·∫øu m√†u cam.</li>
                <li>**Ch·∫°y & Xu·∫•t File:** Nh·∫•n **"B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng"** v√† **"T·∫°o T·ªáp GIF"** (y√™u c·∫ßu file `gif.worker.js`).</li>
            </ol>
            <div class="mt-4 text-xs italic text-gray-500">
                L∆∞u √Ω: Ch·∫ø ƒë·ªô Vector Field m√¥ ph·ªèng s·ª± di chuy·ªÉn ƒë·ªìng b·ªô c·ªßa v·∫≠t li·ªáu trong m·ªôt v√πng k√≠n theo h∆∞·ªõng ƒë√£ ƒë∆∞·ª£c x√°c ƒë·ªãnh.
            </div>
            <div class="mt-6 flex justify-end">
                <button onclick="closeModal('helpModal')" class="py-2 px-4 bg-gray-300 text-gray-800 font-semibold rounded-lg hover:bg-gray-400 transition text-sm">ƒê√≥ng</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.js"></script>
    <script>
        // --- C√ÅC THI·∫æT L·∫¨P BAN ƒê·∫¶U ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const baseImageUpload = document.getElementById('baseImageUpload');
        const materialImageUpload = document.getElementById('materialImageUpload');
        const startStopSimButton = document.getElementById('startStopSim');
        const generateGifButton = document.getElementById('generateGif');
        const resetPathsButton = document.getElementById('resetPaths');
        const addPathButton = document.getElementById('addPathButton'); 
        const editPathButton = document.getElementById('editPathButton'); 
        const addVectorFieldButton = document.getElementById('addVectorFieldButton'); 

        const statusMessage = document.getElementById('statusMessage');
        const placeholderText = document.getElementById('placeholderText');
        const speedControl = document.getElementById('speedControl');
        const speedValueSpan = document.getElementById('speedValue');
        const intensityControl = document.getElementById('intensityControl');
        const intensityValueSpan = document.getElementById('intensityValue');
        const drawThicknessControl = document.getElementById('drawThicknessControl');
        const drawThicknessValueSpan = document.getElementById('drawThicknessValue');

        let animationFrameId = null;
        let isSimulating = false;
        let isPathMode = false;      
        let isVectorMode = false;    
        let isDrawing = false;       
        let isEditMode = false;      
        let activeEditPoint = null;  

        let baseImage = new Image();
        let materialImage = new Image();
        let flowPaths = []; 
        let currentDrawingPath = null;  

        let particles = [];
        let simTime = 0;
        const PARTICLE_COUNT_PER_PATH = 150;
        const PARTICLE_SPEED_BASE = 0.0005; 
        let currentParticleSpeed = PARTICLE_SPEED_BASE * 5; 
        const MATERIAL_SIZE = 32;   
        const MIN_PATH_POINTS = 50;
        const NODE_SIZE = 8;    
        const NODE_HIT_RANGE = 12;

        let flowIntensity = 0.7; 
        let currentDrawThickness = 3;

        // --- C√ÅC H√ÄM TI·ªÜN √çCH ---

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function calculatePathDistances(pathObj) {
            if (pathObj.type !== 'line' || pathObj.points.length < 2) return;
            pathObj.distances = [0];
            pathObj.totalLength = 0;
            
            for (let i = 1; i < pathObj.points.length; i++) {
                const dist = distance(pathObj.points[i - 1], pathObj.points[i]);
                pathObj.totalLength += dist;
                pathObj.distances.push(pathObj.totalLength);
            }
            if (pathObj.totalLength === 0 && pathObj.points.length > 0) {
                pathObj.totalLength = 0.001;
            }
        }

        function getPositionOnPath(t, pathObj) {
            if (pathObj.points.length < 2 || pathObj.totalLength === 0) return null;
            t = Math.max(0, Math.min(1, t));
            const targetDistance = t * pathObj.totalLength;
            
            let startIndex = 0;
            for (let i = 1; i < pathObj.distances.length; i++) {
                if (pathObj.distances[i] >= targetDistance) {
                    startIndex = i - 1;
                    break;
                }
            }

            if (t === 1) return pathObj.points[pathObj.points.length - 1];
            const p1 = pathObj.points[startIndex];
            const p2 = pathObj.points[startIndex + 1];

            const dist1 = pathObj.distances[startIndex];
            const segmentLength = pathObj.distances[startIndex + 1] - dist1;
            
            const localT = segmentLength === 0 ? 0 : (targetDistance - dist1) / segmentLength;

            const x = lerp(p1.x, p2.x, localT);
            const y = lerp(p1.y, p2.y, localT);
            return { x, y };
        }

        /**
         * @description Kh·ªüi t·∫°o c√°c h·∫°t cho m·ªôt path c·ª• th·ªÉ.
         */
        function initializeParticles(pathIndex) {
            const path = flowPaths[pathIndex];
            // X√≥a c√°c h·∫°t c≈© c·ªßa path n√†y tr∆∞·ªõc khi t·∫°o m·ªõi (ch·ªß y·∫øu khi reset/edit)
            particles = particles.filter(p => p.pathIndex !== pathIndex);

            if (path.type === 'line') {
                if (path.points.length < MIN_PATH_POINTS) return; 

                for (let i = 0; i < PARTICLE_COUNT_PER_PATH; i++) {
                    particles.push({
                        t: Math.random(),
                        pathIndex: pathIndex,  
                        offset: Math.random() * 0.05,
                        size: lerp(0.5, 1.5, Math.random()),
                        type: 'line'
                    });
                }
            } else if (path.type === 'vector') { 
                // ƒê·∫£m b·∫£o Vector path c√≥ 2 ƒëi·ªÉm
                if (path.points.length < 2) return;
                
                const minX = Math.min(path.points[0].x, path.points[1].x);
                const maxX = Math.max(path.points[0].x, path.points[1].x);
                const minY = Math.min(path.points[0].y, path.points[1].y);
                const maxY = Math.max(path.points[0].y, path.points[1].y);
                
                const area = (maxX - minX) * (maxY - minY);
                const densityFactor = 0.01; 
                const count = Math.min(300, Math.floor(area * densityFactor)); 

                for (let i = 0; i < count; i++) {
                     let pX = lerp(minX, maxX, Math.random());
                     let pY = lerp(minY, maxY, Math.random());

                    particles.push({
                        x: pX,
                        y: pY,
                        pathIndex: pathIndex,
                        size: lerp(0.5, 1.5, Math.random()),
                        type: 'vector',
                        offset: Math.random() * 5 
                    });
                }
            }
        }

        /**
         * @description C·∫≠p nh·∫≠t v·ªã tr√≠ c·ªßa t·∫•t c·∫£ c√°c h·∫°t.
         */
        function updateParticles() {
            simTime += 0.01;
            particles.forEach(p => {
                const pathObj = flowPaths[p.pathIndex]; 
                if (!pathObj) return;

                if (p.type === 'line') {
                    p.t += currentParticleSpeed;

                    if (p.t > 1) {
                        p.t = p.t - 1;
                        p.t += (Math.random() * currentParticleSpeed * 5); 
                    }
                } else if (p.type === 'vector') {
                    if (pathObj.points.length < 2) return;
                    
                    const speed = currentParticleSpeed * 50; 
                    
                    // L·∫•y ra bounds t·ª´ 2 ƒëi·ªÉm neo
                    const minX = Math.min(pathObj.points[0].x, pathObj.points[1].x);
                    const maxX = Math.max(pathObj.points[0].x, pathObj.points[1].x);
                    const minY = Math.min(pathObj.points[0].y, pathObj.points[1].y);
                    const maxY = Math.max(pathObj.points[0].y, pathObj.points[1].y);
                    
                    const bounds = {minX, maxX, minY, maxY};

                    let dx = 0;
                    let dy = 0;
                    // L·∫•y h∆∞·ªõng ƒë√£ ƒë∆∞·ª£c x√°c ƒë·ªãnh t·ª± ƒë·ªông
                    switch (pathObj.direction) {
                        case 'right': dx = speed; break;
                        case 'left': dx = -speed; break;
                        case 'up': dy = -speed; break;
                        case 'down': dy = speed; break;
                    }

                    p.x += dx + Math.sin(simTime * 10 + p.offset) * 0.5; 
                    p.y += dy + Math.cos(simTime * 10 + p.offset) * 0.5;

                    // Ki·ªÉm tra v√† reset v·ªã tr√≠ (t√°i t·∫°o d√≤ng ch·∫£y tu·∫ßn ho√†n)
                    if (p.x < bounds.minX) p.x = bounds.maxX;
                    if (p.x > bounds.maxX) p.x = bounds.minX;
                    if (p.y < bounds.minY) p.y = bounds.maxY;
                    if (p.y > bounds.maxY) p.y = bounds.minY;
                }
            });
        }

        function getClosestNode(x, y) {
            let closest = null;
            let minDist = NODE_HIT_RANGE;

            for (let pIndex = 0; pIndex < flowPaths.length; pIndex++) {
                const path = flowPaths[pIndex];
                if (path.type !== 'line') continue; 
                
                // Ch·ªâ ki·ªÉm tra c√°c ƒëi·ªÉm neo (m·ªói 10 ƒëi·ªÉm)
                const pointsToExamine = [];
                for (let i = 0; i < path.points.length; i += 10) {
                    pointsToExamine.push({point: path.points[i], index: i});
                }
                const lastIndex = path.points.length - 1;
                if (lastIndex % 10 !== 0 && lastIndex >= 0) {
                    pointsToExamine.push({point: path.points[lastIndex], index: lastIndex});
                }

                pointsToExamine.forEach(({point, index}) => {
                    const dist = distance(point, { x, y });

                    if (dist < minDist) {
                        minDist = dist;
                        closest = { pathIndex: pIndex, pointIndex: index };
                    }
                });
            }
            return closest;
        }


        // --- H√ÄM V·∫º CH√çNH ---

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω h√¨nh n·ªÅn
            let drawArea = { x: 0, y: 0, w: canvas.width, h: canvas.height, offsetX: 0, offsetY: 0 };
            if (baseImage.complete && baseImage.naturalWidth !== 0) {
                const aspectRatio = baseImage.naturalWidth / baseImage.naturalHeight;
                if (canvas.width / canvas.height > aspectRatio) {
                    drawArea.h = canvas.height;
                    drawArea.w = drawArea.h * aspectRatio;
                    drawArea.offsetX = (canvas.width - drawArea.w) / 2;
                } else {
                    drawArea.w = canvas.width;
                    drawArea.h = drawArea.w / aspectRatio;
                    drawArea.offsetY = (canvas.height - drawArea.h) / 2;
                }

                ctx.drawImage(baseImage, drawArea.offsetX, drawArea.offsetY, drawArea.w, drawArea.h);
                placeholderText.classList.add('hidden');
                addPathButton.disabled = false;
                addVectorFieldButton.disabled = false;
                editPathButton.disabled = flowPaths.filter(p => p.type === 'line').length === 0;
            } else {
                placeholderText.classList.remove('hidden');
                addPathButton.disabled = true;
                addVectorFieldButton.disabled = true;
                editPathButton.disabled = true;
                return;
            }

            // 2. V·∫º T·∫§T C·∫¢ C√ÅC ƒê∆Ø·ªúNG ƒêI ƒê√É ƒê·ªäNH NGHƒ®A (ƒê∆Ø·ªúNG THAM CHI·∫æU)
            flowPaths.forEach(path => {
                if (path.type === 'line') {
                    // Ch·ªâ v·∫Ω Line Path n·∫øu Opacity = 1.0 (ho·∫∑c khi ƒëang v·∫Ω)
                    if (path.points.length > 1 && (flowIntensity === 1.0 || (isDrawing && path === currentDrawingPath))) { 
                        ctx.strokeStyle = '#f97316'; // M√†u cam
                        ctx.lineWidth = path.thickness || 3; 
                        ctx.setLineDash([]); 

                        ctx.beginPath();
                        ctx.moveTo(path.points[0].x, path.points[0].y);
                        
                        for (let i = 1; i < path.points.length; i++) {
                            ctx.lineTo(path.points[i].x, path.points[i].y);
                        }
                        ctx.stroke();
                    }

                    // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô ch·ªânh s·ª≠a, v·∫Ω c√°c ƒëi·ªÉm neo cho Line Path
                    if (isEditMode) {
                        const pointsToDraw = [];
                        for (let i = 0; i < path.points.length; i += 10) {
                            pointsToDraw.push({point: path.points[i], index: i});
                        }
                        const lastIndex = path.points.length - 1;
                        if (lastIndex % 10 !== 0 && lastIndex >= 0) {
                            pointsToDraw.push({point: path.points[lastIndex], index: lastIndex});
                        }

                        pointsToDraw.forEach(({point, index}) => {
                            ctx.fillStyle = (activeEditPoint && activeEditPoint.pathIndex === flowPaths.indexOf(path) && activeEditPoint.pointIndex === index) ? '#ef4444' : '#10b981'; 
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, NODE_SIZE / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        });
                    }
                } else if (path.type === 'vector') {
                    // V·∫Ω khung c·ªßa Vector Field Path
                    if (path.points.length >= 2) {
                        const minX = Math.min(path.points[0].x, path.points[1].x);
                        const maxX = Math.max(path.points[0].x, path.points[1].x);
                        const minY = Math.min(path.points[0].y, path.points[1].y);
                        const maxY = Math.max(path.points[0].y, path.points[1].y);

                        const w = maxX - minX;
                        const h = maxY - minY;

                        ctx.strokeStyle = '#06b6d4'; 
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]); 
                        ctx.strokeRect(minX, minY, w, h);
                        ctx.setLineDash([]); 

                        ctx.fillStyle = '#06b6d4';
                        ctx.font = '18px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        let arrow = '';
                        switch (path.direction) {
                            case 'right': arrow = '‚û°Ô∏è'; break;
                            case 'left': arrow = '‚¨ÖÔ∏è'; break;
                            case 'up': arrow = '‚¨ÜÔ∏è'; break;
                            case 'down': arrow = '‚¨áÔ∏è'; break;
                            default: arrow = '?'; break;
                        }
                        // Ch·ªâ v·∫Ω m≈©i t√™n n·∫øu V√πng ƒë√£ ƒë∆∞·ª£c x√°c ƒë·ªãnh
                        ctx.fillText(arrow, minX + w / 2, minY + h / 2);
                    }
                }
            });

            // 3. V·∫º H·ªÜ TH·ªêNG H·∫†T V√Ä √ÅP D·ª§NG C∆Ø·ªúNG ƒê·ªò (OPACITY)
            if (isSimulating) {
                ctx.globalAlpha = flowIntensity;
                particles.forEach(p => {
                    const pathObj = flowPaths[p.pathIndex]; 
                    if (!pathObj) return;

                    let pos = { x: 0, y: 0 };
                    if (p.type === 'line') {
                        if (pathObj.points.length < MIN_PATH_POINTS) return;
                        pos = getPositionOnPath(p.t, pathObj);
                    } else if (p.type === 'vector') {
                        pos = { x: p.x, y: p.y };
                    }
                    
                    if (pos) {
                        const size = MATERIAL_SIZE * p.size;
                        const halfSize = size / 2;
                        
                        const noiseX = p.type === 'line' ? Math.sin(p.t * 50 + simTime) * 3 * p.offset : 0;
                        const noiseY = p.type === 'line' ? Math.cos(p.t * 30 + simTime) * 3 * p.offset : 0;
                        
                        const x = pos.x - halfSize + noiseX;
                        const y = pos.y - halfSize + noiseY;

                        if (materialImage.complete && materialImage.naturalWidth !== 0) {
                            ctx.drawImage(materialImage, x, y, size, size);
                        } else {
                            ctx.fillStyle = '#facc15'; 
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, halfSize * 0.7, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                ctx.globalAlpha = 1.0; 
            }

            // 4. Th√¥ng b√°o tr·∫°ng th√°i v·∫Ω
            if (isDrawing && currentDrawingPath) {
                const pointsCount = currentDrawingPath.points.length;
                if (pointsCount > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
                    ctx.fillStyle = '#374151';
                    ctx.font = '14px Inter';
                    ctx.textAlign = 'center';
                    
                    if (currentDrawingPath.type === 'line') {
                        const lineText = `ƒêang v·∫Ω ƒê∆∞·ªùng Line (${pointsCount} ƒëi·ªÉm). Nh·∫£ chu·ªôt ƒë·ªÉ k·∫øt th√∫c.`;
                        ctx.fillText(lineText, canvas.width / 2, canvas.height - 10);
                    } else if (currentDrawingPath.type === 'vector') {
                         // N·∫øu ƒëang v·∫Ω Vector, hi·ªÉn th·ªã P1 v√† P2
                         const p1 = currentDrawingPath.points[0];
                         const p2 = currentDrawingPath.points[1] || {x: finalX, y: finalY};
                         
                         ctx.strokeStyle = '#06b6d4'; 
                         ctx.lineWidth = 2;
                         ctx.setLineDash([5, 5]); 
                         ctx.strokeRect(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.abs(p2.x - p1.x), Math.abs(p2.y - p1.y));
                         ctx.setLineDash([]); 

                        const vectorText = "ƒêang v·∫Ω V√πng Vector. K√©o v√† **Nh·∫£ chu·ªôt** ƒë·ªÉ x√°c nh·∫≠n v√πng v√† h∆∞·ªõng.";
                        ctx.fillText(vectorText, canvas.width / 2, canvas.height - 10);
                    }
                }
            }
        }

        function animate() {
            if (isSimulating) {
                updateParticles();
            }
            draw();
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- X·ª¨ L√ù S·ª∞ KI·ªÜN CHU·ªòT/C·∫¢M ·ª®NG ---

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;
            return { x, y };
        }

        // --- MOUSE DOWN / TOUCH START ---
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', (e) => {
            if (isPathMode || isVectorMode || isEditMode) {
                e.preventDefault(); 
            }
            handleStart(e);
        }, { passive: false });

        function handleStart(e) {
            const { x, y } = getCoords(e);
            
            if (isPathMode && !isDrawing) {
                // B·∫Øt ƒë·∫ßu v·∫Ω Line Path
                isDrawing = true;
                currentDrawingPath = {
                    points: [],
                    distances: [],
                    totalLength: 0,
                    thickness: currentDrawThickness,
                    type: 'line'
                };
                flowPaths.push(currentDrawingPath);
                currentDrawingPath.points.push({ x, y });
                draw();
            } 
            else if (isVectorMode && !isDrawing) {
                // B·∫Øt ƒë·∫ßu v·∫Ω Vector Field (ch·ªâ c·∫ßn ƒëi·ªÉm neo P1)
                isDrawing = true;
                currentDrawingPath = {
                    points: [{ x, y }], 
                    direction: null,   
                    type: 'vector',
                    thickness: 1 
                };
                flowPaths.push(currentDrawingPath);
                draw();
                statusMessage.textContent = "ƒêang v·∫Ω V√πng Vector. K√©o chu·ªôt ƒë·ªÉ t·∫°o v√πng, Nh·∫£ chu·ªôt ƒë·ªÉ x√°c nh·∫≠n h∆∞·ªõng.";
            }
            else if (isEditMode && flowPaths.length > 0) {
                const node = getClosestNode(x, y);
                if (node) {
                    activeEditPoint = node;
                    canvas.classList.add('grabbing');
                    statusMessage.textContent = `ƒêang k√©o ƒëi·ªÉm neo V√πng ${node.pathIndex + 1}...`;
                }
            }
        }

        // --- MOUSE MOVE / TOUCH MOVE ---
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('touchmove', (e) => {
            if (isDrawing || activeEditPoint) {
                e.preventDefault();
            }
            handleMove(e);
        }, { passive: false });

        function handleMove(e) {
            const { x, y } = getCoords(e);

            if (isDrawing && currentDrawingPath) {
                if (currentDrawingPath.type === 'line') {
                    // Th√™m ƒëi·ªÉm li√™n t·ª•c cho Line Path
                    const lastPoint = currentDrawingPath.points[currentDrawingPath.points.length - 1];
                    if (distance(lastPoint, { x, y }) > 1) { // L·∫•y m·∫´u ƒëi·ªÉm ƒë·ªÉ t·ªëi ∆∞u
                        currentDrawingPath.points.push({ x, y });
                    }
                } else if (currentDrawingPath.type === 'vector') {
                    // C·∫≠p nh·∫≠t ƒëi·ªÉm k·∫øt th√∫c (P2) cho V√πng Vector
                    if (currentDrawingPath.points.length === 1) {
                        currentDrawingPath.points.push({ x, y });
                    } else {
                        currentDrawingPath.points[1] = { x, y };
                    }
                }
                draw();
            } else if (activeEditPoint) {
                // Di chuy·ªÉn ƒëi·ªÉm neo trong Edit Mode
                const path = flowPaths[activeEditPoint.pathIndex];
                path.points[activeEditPoint.pointIndex] = { x, y };
                draw();
            }
        }

        // --- MOUSE UP / TOUCH END ---
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        function handleEnd(e) {
            if (isDrawing && currentDrawingPath) {
                
                // L·∫•y t·ªça ƒë·ªô cu·ªëi c√πng (cho c·∫£ Line v√† Vector)
                let finalX, finalY;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    const rect = canvas.getBoundingClientRect();
                    finalX = e.changedTouches[0].clientX - rect.left;
                    finalY = e.changedTouches[0].clientY - rect.top;
                } else {
                    const { x, y } = getCoords(e);
                    finalX = x;
                    finalY = y;
                }
                
                // Logic x·ª≠ l√Ω k·∫øt th√∫c v·∫Ω V√πng Vector
                if (currentDrawingPath.type === 'vector') {
                    if (currentDrawingPath.points.length === 1) {
                        currentDrawingPath.points.push({ x: finalX, y: finalY });
                    } else {
                        currentDrawingPath.points[1] = { x: finalX, y: finalY }; 
                    }

                    const startX = currentDrawingPath.points[0].x;
                    const startY = currentDrawingPath.points[0].y;
                    const endX = finalX;
                    const endY = finalY;
                    
                    const dx = endX - startX;
                    const dy = endY - startY;
                    
                    // X√°c ƒë·ªãnh h∆∞·ªõng theo chi·ªÅu k√©o l·ªõn nh·∫•t (ch·ªß ƒë·∫°o)
                    const minSize = 20; 
                    if (Math.abs(dx) > minSize || Math.abs(dy) > minSize) {
                        if (Math.abs(dx) > Math.abs(dy)) {
                            currentDrawingPath.direction = (dx > 0) ? 'right' : 'left';
                        } else {
                            currentDrawingPath.direction = (dy > 0) ? 'down' : 'up';
                        }
                        initializeParticles(flowPaths.length - 1);
                        statusMessage.textContent = `‚úÖ V√πng Vector ƒë√£ ƒë∆∞·ª£c t·∫°o. H∆∞·ªõng: ${currentDrawingPath.direction.toUpperCase()}.`;
                    } else {
                        flowPaths.pop(); // H·ªßy b·ªè n·∫øu qu√° nh·ªè
                        statusMessage.textContent = "‚ùå V√πng Vector qu√° nh·ªè ho·∫∑c ch∆∞a ƒë∆∞·ª£c k√©o chu·ªôt. Vui l√≤ng th·ª≠ l·∫°i.";
                    }
                    
                    isVectorMode = false;
                } 
                // Logic x·ª≠ l√Ω k·∫øt th√∫c v·∫Ω Line Path
                else if (currentDrawingPath.type === 'line') {
                    if (currentDrawingPath.points.length < MIN_PATH_POINTS) {
                        flowPaths.pop(); 
                        statusMessage.textContent = "‚ùå ƒê∆∞·ªùng Line qu√° ng·∫Øn! Vui l√≤ng v·∫Ω ƒë∆∞·ªùng d√†i h∆°n.";
                    } else {
                        calculatePathDistances(currentDrawingPath);
                        initializeParticles(flowPaths.length - 1);
                        statusMessage.textContent = `‚úÖ ƒê∆∞·ªùng Line ${flowPaths.length} ƒë√£ ƒë∆∞·ª£c t·∫°o v√† s·∫µn s√†ng m√¥ ph·ªèng.`;
                    }
                    isPathMode = false;
                }

                // ƒê·∫∑t l·∫°i tr·∫°ng th√°i chung
                isDrawing = false;
                currentDrawingPath = null;
                canvas.classList.remove('drawing-mode');
                
                // C·∫≠p nh·∫≠t n√∫t
                addVectorFieldButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                addVectorFieldButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                addVectorFieldButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (Vector)';
                
                addPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                addPathButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                addPathButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)';
                
                startStopSimButton.disabled = flowPaths.length === 0;

            } else if (activeEditPoint) {
                // K·∫øt th√∫c k√©o ƒëi·ªÉm neo
                const path = flowPaths[activeEditPoint.pathIndex];
                if (path.type === 'line') {
                    calculatePathDistances(path); 
                    initializeParticles(activeEditPoint.pathIndex); 
                }
                activeEditPoint = null;
                canvas.classList.remove('grabbing');
                statusMessage.textContent = 'ƒê√£ ho√†n t·∫•t ch·ªânh s·ª≠a ƒëi·ªÉm neo.';
            }
            draw();
        }

        // --- X·ª¨ L√ù N√öT TH√äM V√ôNG LINE (PEN/BRUSH MODE) ---
        addPathButton.addEventListener('click', () => {
            isVectorMode = false; 
            isEditMode = false;
            activeEditPoint = null;
            canvas.classList.remove('edit-mode');
            
            // ƒê·∫£m b·∫£o n√∫t Vector kh√¥ng c√≤n b·ªã nh·∫•n
            addVectorFieldButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            addVectorFieldButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
            addVectorFieldButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (Vector)';

            isPathMode = !isPathMode;

            if (isPathMode) {
                canvas.classList.add('drawing-mode');
                addPathButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                addPathButton.classList.add('bg-gray-600', 'hover:bg-gray-700');
                addPathButton.textContent = 'üî¥ H·ª¶Y ƒê∆∞·ªùng Line (ƒêang V·∫Ω)';
                statusMessage.textContent = "Ch·∫ø ƒë·ªô ƒê∆∞·ªùng Line: Nh·∫•n v√† gi·ªØ chu·ªôt ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒëi t·ª± do.";
            } else {
                canvas.classList.remove('drawing-mode');
                addPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                addPathButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                addPathButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)';
                statusMessage.textContent = "ƒê√£ h·ªßy ch·∫ø ƒë·ªô v·∫Ω ƒê∆∞·ªùng Line.";
            }
            draw();
        });

        // --- X·ª¨ L√ù N√öT TH√äM V√ôNG VECTOR (KHU V·ª∞C) ---
        addVectorFieldButton.addEventListener('click', () => {
            isPathMode = false;
            isEditMode = false;
            activeEditPoint = null;
            canvas.classList.remove('edit-mode');
            
            // ƒê·∫£m b·∫£o n√∫t Line kh√¥ng c√≤n b·ªã nh·∫•n
            addPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            addPathButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            addPathButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)';


            isVectorMode = !isVectorMode; 

            if (isVectorMode) {
                canvas.classList.add('drawing-mode');
                addVectorFieldButton.classList.remove('bg-cyan-600', 'hover:bg-cyan-700');
                addVectorFieldButton.classList.add('bg-gray-600', 'hover:bg-gray-700');
                addVectorFieldButton.textContent = 'üî¥ H·ª¶Y V√πng Vector (ƒêang V·∫Ω)';
                statusMessage.textContent = "Ch·∫ø ƒë·ªô V√πng Vector: **Nh·∫•n v√† K√©o chu·ªôt** ƒë·ªÉ t·∫°o v√πng. H∆∞·ªõng s·∫Ω ƒë∆∞·ª£c x√°c ƒë·ªãnh theo chi·ªÅu k√©o chu·ªôt.";
            } else {
                canvas.classList.remove('drawing-mode');
                addVectorFieldButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                addVectorFieldButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                addVectorFieldButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (Vector)';
                statusMessage.textContent = "ƒê√£ h·ªßy ch·∫ø ƒë·ªô v·∫Ω V√πng Vector.";
            }
            draw();
        });


        // --- X·ª¨ L√ù N√öT CH·ªàNH S·ª¨A ---
        editPathButton.addEventListener('click', () => {
            isPathMode = false;
            isVectorMode = false;
            canvas.classList.remove('drawing-mode');
            
            // ƒê·∫£m b·∫£o n√∫t Line/Vector kh√¥ng c√≤n b·ªã nh·∫•n
            addPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            addPathButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            addPathButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)';
            
            addVectorFieldButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            addVectorFieldButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
            addVectorFieldButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (Vector)';


            isEditMode = !isEditMode;

            if (isEditMode) {
                canvas.classList.add('edit-mode');
                editPathButton.classList.remove('bg-pink-500', 'hover:bg-pink-600');
                editPathButton.classList.add('bg-gray-600', 'hover:bg-gray-700');
                editPathButton.textContent = '‚úÖ ƒê√£ B·∫≠t Ch·∫ø ƒê·ªô Ch·ªânh S·ª≠a (Tho√°t)';
                statusMessage.textContent = "Ch·∫ø ƒë·ªô Ch·ªânh s·ª≠a: K√©o c√°c ƒëi·ªÉm neo m√†u xanh l√° tr√™n ƒë∆∞·ªùng Line ƒë·ªÉ ƒëi·ªÅu ch·ªânh.";
            } else {
                canvas.classList.remove('edit-mode');
                editPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                editPathButton.classList.add('bg-pink-500', 'hover:bg-pink-600');
                editPathButton.textContent = 'Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)';
                statusMessage.textContent = "ƒê√£ tho√°t ch·∫ø ƒë·ªô ch·ªânh s·ª≠a.";
            }
            draw();
        });

        // --- X·ª¨ L√ù N√öT START/STOP M√î PH·ªéNG ---
        startStopSimButton.addEventListener('click', () => {
            isSimulating = !isSimulating;
            if (isSimulating) {
                startStopSimButton.textContent = 'T·∫†M D·ª™NG M√¥ Ph·ªèng';
                startStopSimButton.classList.remove('bg-green-600');
                startStopSimButton.classList.add('bg-red-600');
                generateGifButton.disabled = false; 
                
                if (particles.length === 0 && flowPaths.length > 0) {
                     flowPaths.forEach((_, index) => initializeParticles(index));
                }
                
                if (animationFrameId === null) {
                    animate();
                }
                statusMessage.textContent = "üöÄ ƒêang M√¥ Ph·ªèng D√≤ng Ch·∫£y V·∫≠t Li·ªáu...";

            } else {
                startStopSimButton.textContent = 'TI·∫æP T·ª§C M√¥ Ph·ªèng';
                startStopSimButton.classList.remove('bg-red-600');
                startStopSimButton.classList.add('bg-green-600');
                statusMessage.textContent = "‚è∏Ô∏è M√¥ Ph·ªèng ƒë√£ t·∫°m d·ª´ng.";
            }
        });


        // --- X·ª¨ L√ù INPUTS ---

        baseImageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                baseImage.src = URL.createObjectURL(file);
                baseImage.onload = () => {
                    resizeCanvas();
                    statusMessage.textContent = "·∫¢nh n·ªÅn ƒë√£ t·∫£i l√™n. S·∫µn s√†ng v·∫Ω v√πng m√¥ ph·ªèng.";
                };
            }
        });

        materialImageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                materialImage.src = URL.createObjectURL(file);
                materialImage.onload = () => {
                    statusMessage.textContent = "·∫¢nh v·∫≠t li·ªáu ƒë√£ t·∫£i l√™n.";
                    draw();
                };
            }
        });

        speedControl.addEventListener('input', (e) => {
            currentParticleSpeed = PARTICLE_SPEED_BASE * parseFloat(e.target.value);
            speedValueSpan.textContent = e.target.value;
        });

        intensityControl.addEventListener('input', (e) => {
            flowIntensity = parseFloat(e.target.value);
            intensityValueSpan.textContent = `${Math.round(flowIntensity * 100)}%`;
            draw(); 
        });
        
        drawThicknessControl.addEventListener('input', (e) => {
            currentDrawThickness = parseInt(e.target.value);
            drawThicknessValueSpan.textContent = `${currentDrawThickness} px`;
            flowPaths.filter(p => p.type === 'line').forEach(path => path.thickness = currentDrawThickness);
            draw();
        });

        resetPathsButton.addEventListener('click', () => {
            flowPaths = [];
            particles = [];
            isSimulating = false;
            isPathMode = false;
            isVectorMode = false;
            isDrawing = false;
            isEditMode = false;

            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            startStopSimButton.textContent = 'B·∫ÆT ƒê·∫¶U M√¥ Ph·ªèng';
            startStopSimButton.classList.remove('bg-red-600');
            startStopSimButton.classList.add('bg-green-600');
            startStopSimButton.disabled = true;
            generateGifButton.disabled = true;

            // Reset n√∫t v·∫Ω/ch·ªânh s·ª≠a
            addPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            addPathButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            addPathButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (ƒê∆∞·ªùng Line)';
            editPathButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            editPathButton.classList.add('bg-pink-500', 'hover:bg-pink-600');
            editPathButton.textContent = 'Ch·ªçn/Ch·ªânh S·ª≠a V√πng V·∫Ω (Line)';
            addVectorFieldButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            addVectorFieldButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
            addVectorFieldButton.textContent = '+ Th√™m V√πng D√≤ng Ch·∫£y (Vector)';

            canvas.classList.remove('drawing-mode', 'edit-mode');

            statusMessage.textContent = "ƒê√£ x√≥a to√†n b·ªô V√πng M√¥ Ph·ªèng.";
            draw();
        });

        // --- H√ÄM T·∫†O V√Ä XU·∫§T GIF ---
        generateGifButton.addEventListener('click', async () => {
            if (flowPaths.length === 0) {
                alert("Vui l√≤ng v·∫Ω √≠t nh·∫•t m·ªôt v√πng m√¥ ph·ªèng tr∆∞·ªõc.");
                return;
            }

            const wasSimulating = isSimulating;
            if (wasSimulating) {
                isSimulating = false;
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                startStopSimButton.textContent = 'TI·∫æP T·ª§C M√¥ Ph·ªèng';
                startStopSimButton.classList.remove('bg-red-600');
                startStopSimButton.classList.add('bg-green-600');
            }
            
            statusMessage.textContent = "‚è≥ ƒêang T·∫°o GIF... Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i gi√¢y.";
            generateGifButton.disabled = true;

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: canvas.width,
                height: canvas.height
            });

            const FRAMES = 150; 
            const delay = 33;   

            // Sao ch√©p tr·∫°ng th√°i h·∫°t hi·ªán t·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o GIF b·∫Øt ƒë·∫ßu t·ª´ ƒë√∫ng v·ªã tr√≠
            const initialParticlesState = JSON.parse(JSON.stringify(particles)); 
            
            let tempParticles = JSON.parse(JSON.stringify(initialParticlesState));
            let tempSimTime = simTime; 

            // T·∫°m th·ªùi b·∫≠t c·ªù m√¥ ph·ªèng ch·ªâ cho vi·ªác t·∫°o frame
            let tempIsSimulating = true;

            for (let i = 0; i < FRAMES; i++) {
                // S·ª≠ d·ª•ng h√†m c·∫≠p nh·∫≠t v√† v·∫Ω t·∫°m th·ªùi
                const updateAndDrawFrame = () => {
                    tempSimTime += 0.01;
                    tempParticles.forEach(p => {
                        const pathObj = flowPaths[p.pathIndex]; 
                        if (!pathObj) return;

                        if (p.type === 'line') {
                            p.t += currentParticleSpeed;

                            if (p.t > 1) {
                                p.t = p.t - 1;
                                p.t += (Math.random() * currentParticleSpeed * 5); 
                            }
                        } else if (p.type === 'vector') {
                            if (pathObj.points.length < 2) return;
                            
                            const speed = currentParticleSpeed * 50; 
                            const minX = Math.min(pathObj.points[0].x, pathObj.points[1].x);
                            const maxX = Math.max(pathObj.points[0].x, pathObj.points[1].x);
                            const minY = Math.min(pathObj.points[0].y, pathObj.points[1].y);
                            const maxY = Math.max(pathObj.points[0].y, pathObj.points[1].y);
                            const bounds = {minX, maxX, minY, maxY};

                            let dx = 0;
                            let dy = 0;
                            switch (pathObj.direction) {
                                case 'right': dx = speed; break;
                                case 'left': dx = -speed; break;
                                case 'up': dy = -speed; break;
                                case 'down': dy = speed; break;
                            }

                            p.x += dx + Math.sin(tempSimTime * 10 + p.offset) * 0.5; 
                            p.y += dy + Math.cos(tempSimTime * 10 + p.offset) * 0.5;

                            if (p.x < bounds.minX) p.x = bounds.maxX;
                            if (p.x > bounds.maxX) p.x = bounds.minX;
                            if (p.y < bounds.minY) p.y = bounds.maxY;
                            if (p.y > bounds.maxY) p.y = bounds.minY;
                        }
                    });

                    // V·∫Ω Frame
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // V·∫Ω n·ªÅn (l·∫•y t·ª´ h√†m draw ch√≠nh)
                    let drawArea = { x: 0, y: 0, w: canvas.width, h: canvas.height, offsetX: 0, offsetY: 0 };
                    if (baseImage.complete && baseImage.naturalWidth !== 0) {
                        const aspectRatio = baseImage.naturalWidth / baseImage.naturalHeight;
                        if (canvas.width / canvas.height > aspectRatio) {
                            drawArea.h = canvas.height;
                            drawArea.w = drawArea.h * aspectRatio;
                            drawArea.offsetX = (canvas.width - drawArea.w) / 2;
                        } else {
                            drawArea.w = canvas.width;
                            drawArea.h = drawArea.w / aspectRatio;
                            drawArea.offsetY = (canvas.height - drawArea.h) / 2;
                        }
                        ctx.drawImage(baseImage, drawArea.offsetX, drawArea.offsetY, drawArea.w, drawArea.h);
                    }
                    
                    // V·∫Ω ƒë∆∞·ªùng tham chi·∫øu (T√πy ch·ªçn, th∆∞·ªùng n√™n ·∫©n trong GIF)
                    // flowPaths.forEach(...) 
                    
                    // V·∫Ω h·∫°t
                    ctx.globalAlpha = flowIntensity;
                    tempParticles.forEach(p => {
                        const pathObj = flowPaths[p.pathIndex]; 
                        if (!pathObj) return;

                        let pos = { x: 0, y: 0 };
                        if (p.type === 'line') {
                            if (pathObj.points.length < MIN_PATH_POINTS) return;
                            pos = getPositionOnPath(p.t, pathObj);
                        } else if (p.type === 'vector') {
                            pos = { x: p.x, y: p.y };
                        }
                        
                        if (pos) {
                            const size = MATERIAL_SIZE * p.size;
                            const halfSize = size / 2;
                            const noiseX = p.type === 'line' ? Math.sin(p.t * 50 + tempSimTime) * 3 * p.offset : 0;
                            const noiseY = p.type === 'line' ? Math.cos(p.t * 30 + tempSimTime) * 3 * p.offset : 0;
                            const x = pos.x - halfSize + noiseX;
                            const y = pos.y - halfSize + noiseY;

                            if (materialImage.complete && materialImage.naturalWidth !== 0) {
                                ctx.drawImage(materialImage, x, y, size, size);
                            } else {
                                ctx.fillStyle = '#facc15'; 
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, halfSize * 0.7, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    });
                    ctx.globalAlpha = 1.0; 
                };

                updateAndDrawFrame();
                
                gif.addFrame(ctx, { delay: delay, copy: true });
                
                statusMessage.textContent = `‚è≥ ƒêang T·∫°o GIF... (${Math.round((i + 1) / FRAMES * 100)}%)`;
                await new Promise(resolve => setTimeout(resolve, 1)); 
            }
            
            // Kh√¥i ph·ª•c tr·∫°ng th√°i m√¥ ph·ªèng
            particles = initialParticlesState;
            simTime = tempSimTime;
            isSimulating = wasSimulating; 
            if (isSimulating) {
                animate();
            } else {
                draw(); // V·∫Ω l·∫°i frame tƒ©nh cu·ªëi c√πng
            }

            // K·∫øt xu·∫•t GIF
            gif.on('finished', function(blob) {
                const gifUrl = URL.createObjectURL(blob);
                const gifPreview = document.getElementById('gifPreview');
                const gifDownloadLink = document.getElementById('gifDownloadLink');

                gifPreview.src = gifUrl;
                gifDownloadLink.href = gifUrl;
                
                document.getElementById('gifPreviewArea').classList.remove('hidden');

                statusMessage.textContent = "‚úÖ T·∫°o GIF th√†nh c√¥ng! Xem tr∆∞·ªõc v√† t·∫£i xu·ªëng b√™n d∆∞·ªõi.";
                generateGifButton.disabled = false;
            });

            gif.render();
        });


        // --- MODAL V√Ä WINDOW LISTENERS ---

        function openModal(id) {
            const modal = document.getElementById(id);
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.remove('scale-95');
            modal.querySelector('div').classList.add('scale-100');
        }

        function closeModal(id) {
            const modal = document.getElementById(id);
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.add('scale-95');
            modal.querySelector('div').classList.remove('scale-100');
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas); 
    </script>
</body>
</html>
