<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRO - M√¥ Ph·ªèng D√≤ng Ch·∫£y Tr√™n N·ªÅn GIF</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/gifuct-js@2.1.2/dist/gifuct-js.min.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.js"></script>
    <style>
        .drawing-mode { cursor: crosshair !important; }
        .edit-mode { cursor: context-menu !important; }
        .grabbing { cursor: grabbing !important; }
        .flow-container { background-color: #f0f4f8; min-height: 100vh; font-family: 'Segoe UI', sans-serif; }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: #4f46e5; border-radius: 50%; cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5); margin-top: -7px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #cbd5e1; border-radius: 2px;
        }

        .header-bg {
            background: linear-gradient(135deg, #0f172a 0%, #334155 100%);
            padding: 2rem 0; color: white; margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="flow-container">

    <div class="header-bg">
        <div class="max-w-7xl mx-auto px-6">
            <h1 class="text-4xl font-extrabold tracking-tight">M√î PH·ªéNG D√íNG CH·∫¢Y PRO</h1>
            <p class="text-gray-300 mt-2">H·ªó tr·ª£ n·ªÅn GIF ƒë·ªông & V√πng ch·ªçn t·ª± do (Lasso Tool)</p>
        </div>
    </div>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-10">
        <div class="flex flex-col lg:flex-row gap-6">

            <div class="lg:w-1/4 space-y-5 p-5 bg-white rounded-xl shadow-lg order-2 lg:order-1 h-fit">
                
                <div class="space-y-3 border-b pb-4">
                    <p class="text-sm font-bold text-gray-500 uppercase">1. ƒê·∫ßu v√†o</p>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-1">·∫¢nh N·ªÅn / GIF ƒê·ªông (M√°y m√≥c)</label>
                        <input type="file" id="baseImageUpload" accept="image/*" class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                    </div>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-1">V·∫≠t Li·ªáu (·∫¢nh tƒ©nh PNG/JPG)</label>
                        <input type="file" id="materialImageUpload" accept="image/*" class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-pink-50 file:text-pink-700 hover:file:bg-pink-100">
                    </div>
                </div>

                <div class="space-y-3 border-b pb-4">
                    <p class="text-sm font-bold text-gray-500 uppercase">2. C√¥ng c·ª• V·∫Ω</p>
                    <button id="addPathButton" disabled class="w-full py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded shadow transition disabled:opacity-50 text-sm">
                        ‚úèÔ∏è V·∫Ω ƒê∆∞·ªùng D·∫´n (Line)
                    </button>
                    <button id="addVectorFieldButton" disabled class="w-full py-2 bg-cyan-600 hover:bg-cyan-700 text-white font-bold rounded shadow transition disabled:opacity-50 text-sm">
                        üñåÔ∏è V·∫Ω V√πng Ch·ª©a (Vector Zone)
                    </button>
                    <button id="resetPaths" class="w-full py-2 bg-red-500 hover:bg-red-600 text-white font-bold rounded shadow transition text-sm">
                        X√≥a T·∫•t C·∫£
                    </button>
                </div>

                <div class="space-y-4 border-b pb-4">
                    <p class="text-sm font-bold text-gray-500 uppercase">3. T√πy Ch·ªânh</p>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>T·ªëc ƒë·ªô h·∫°t</span><span id="speedValue" class="font-bold text-indigo-600">5</span></div>
                        <input type="range" id="speedControl" min="1" max="20" value="5" step="1">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>M·∫≠t ƒë·ªô / S·ªë l∆∞·ª£ng</span><span id="intensityValue" class="font-bold text-indigo-600">80%</span></div>
                        <input type="range" id="intensityControl" min="0.1" max="1.0" value="0.8" step="0.05">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>K√≠ch th∆∞·ªõc h·∫°t</span><span id="sizeValue" class="font-bold text-indigo-600">24px</span></div>
                         <input type="range" id="sizeControl" min="5" max="60" value="24" step="1">
                    </div>
                </div>

                <div class="space-y-3">
                    <button id="startStopSim" disabled class="w-full py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition disabled:opacity-50">
                        ‚ñ∂ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG
                    </button>
                    <button id="generateGif" disabled class="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg shadow-md transition disabled:opacity-50">
                        üé¨ Xu·∫•t File GIF (Gi·ªØ n·ªÅn ƒë·ªông)
                    </button>
                </div>
            </div>

            <div class="lg:w-3/4 space-y-4 order-1 lg:order-2">
                 <div id="statusMessage" class="text-center text-sm font-medium text-indigo-800 bg-indigo-50 p-2 rounded border border-indigo-100">
                    üëã Vui l√≤ng t·∫£i l√™n ·∫£nh n·ªÅn (GIF ho·∫∑c ·∫£nh tƒ©nh) ƒë·ªÉ b·∫Øt ƒë·∫ßu.
                </div>

                <div class="relative canvas-area border-2 border-dashed border-gray-300 rounded-xl overflow-hidden flex justify-center items-center bg-white shadow-inner" style="height: 70vh;">
                    <canvas id="simulationCanvas" class="absolute inset-0 w-full h-full"></canvas>
                    <div id="placeholderText" class="absolute text-gray-400 text-lg pointer-events-none">
                        Khu v·ª±c hi·ªÉn th·ªã b·∫£n v·∫Ω
                    </div>
                    <div id="loadingOverlay" class="absolute inset-0 bg-white bg-opacity-80 z-50 flex items-center justify-center hidden">
                        <div class="text-center">
                            <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-indigo-600 mx-auto mb-2"></div>
                            <span id="loadingText" class="text-indigo-600 font-semibold">ƒêang x·ª≠ l√Ω...</span>
                        </div>
                    </div>
                </div>

                <div id="gifPreviewArea" class="hidden p-4 bg-white rounded-xl shadow border text-center">
                    <h3 class="font-bold text-gray-700 mb-2">K·∫øt qu·∫£ Xu·∫•t File</h3>
                    <img id="gifPreview" class="max-w-full h-auto mx-auto rounded border mb-3" style="max-height: 400px;">
                    <a id="gifDownloadLink" download="simulation_result.gif" class="inline-block py-2 px-6 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700 transition cursor-pointer">
                        üì• T·∫£i Xu·ªëng
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- C·∫§U H√åNH & BI·∫æN TO√ÄN C·ª§C ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Canvas ·∫©n ƒë·ªÉ x·ª≠ l√Ω Mask (V√πng ch·ªçn t·ª± do)
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');

        // Canvas t·∫°m ƒë·ªÉ v·∫Ω frame GIF n·ªÅn
        const bgDrawCanvas = document.createElement('canvas');
        const bgDrawCtx = bgDrawCanvas.getContext('2d');

        let appState = {
            isSimulating: false,
            mode: 'idle', // idle, line, vector
            isDrawing: false,
            bgType: 'image', // 'image' ho·∫∑c 'gif'
            bgImage: null,   // Object Image cho ·∫£nh tƒ©nh
            bgGifFrames: [], // M·∫£ng ch·ª©a frames c·ªßa GIF n·ªÅn
            bgGifDuration: 0,
            materialImage: null,
            paths: [],
            particles: [],
            simTime: 0,
            lastFrameTime: 0
        };

        const CONFIG = {
            maxParticles: 400,
            particleSpeedBase: 0.001,
            vectorSpeedMult: 15
        };

        let currentPath = null;
        let animationId = null;

        // UI Elements
        const statusMsg = document.getElementById('statusMessage');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        
        // --- H√ÄM X·ª¨ L√ù GIF (GI·∫¢I M√É) ---
        function parseGif(arrayBuffer) {
            const gif = new GIF(arrayBuffer);
            return gif.decompressFrames(true);
        }

        async function loadGifFrames(frames) {
            const loadedFrames = [];
            let totalTime = 0;
            
            // Chuy·ªÉn ƒë·ªïi raw patch data sang ImageBitmap ƒë·ªÉ render nhanh h∆°n
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const imageData = new ImageData(
                    new Uint8ClampedArray(frame.patch),
                    frame.dims.width,
                    frame.dims.height
                );
                const bitmap = await createImageBitmap(imageData);
                loadedFrames.push({
                    bitmap: bitmap,
                    delay: frame.delay || 100, // miliseconds
                    dims: frame.dims
                });
                totalTime += (frame.delay || 100);
            }
            return { frames: loadedFrames, duration: totalTime };
        }

        // --- X·ª¨ L√ù S·ª∞ KI·ªÜN UPLOAD ·∫¢NH ---
        
        // 1. Upload ·∫¢nh N·ªÅn (H·ªó tr·ª£ GIF)
        document.getElementById('baseImageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = "ƒêang ph√¢n t√≠ch file n·ªÅn...";
            document.getElementById('placeholderText').classList.add('hidden');

            if (file.type === 'image/gif') {
                appState.bgType = 'gif';
                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const buffer = event.target.result;
                        const rawFrames = parseGif(buffer);
                        const result = await loadGifFrames(rawFrames);
                        
                        appState.bgGifFrames = result.frames;
                        appState.bgGifDuration = result.duration;
                        
                        // Set k√≠ch th∆∞·ªõc canvas theo frame ƒë·∫ßu ti√™n
                        resizeCanvas(result.frames[0].dims.width, result.frames[0].dims.height);
                        
                        statusMsg.textContent = `‚úÖ ƒê√£ t·∫£i GIF n·ªÅn (${result.frames.length} frames). S·∫µn s√†ng v·∫Ω v√πng m√¥ ph·ªèng.`;
                        toggleTools(true);
                    } catch (err) {
                        console.error(err);
                        alert("L·ªói khi ƒë·ªçc file GIF.");
                    } finally {
                        loadingOverlay.classList.add('hidden');
                        drawMain();
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                appState.bgType = 'image';
                const img = new Image();
                img.onload = () => {
                    appState.bgImage = img;
                    resizeCanvas(img.naturalWidth, img.naturalHeight);
                    statusMsg.textContent = "‚úÖ ƒê√£ t·∫£i ·∫£nh n·ªÅn tƒ©nh. S·∫µn s√†ng v·∫Ω.";
                    toggleTools(true);
                    loadingOverlay.classList.add('hidden');
                    drawMain();
                };
                img.src = URL.createObjectURL(file);
            }
        });

        // 2. Upload V·∫≠t Li·ªáu (·∫¢nh tƒ©nh)
        document.getElementById('materialImageUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.onload = () => {
                    appState.materialImage = img;
                    drawMain();
                };
                img.src = URL.createObjectURL(file);
            }
        });

        function resizeCanvas(w, h) {
            // Gi·ªØ t·ª∑ l·ªá khung h√¨nh nh∆∞ng scale cho v·ª´a m√†n h√¨nh
            const container = canvas.parentElement;
            const aspect = w / h;
            let finalW = container.clientWidth;
            let finalH = finalW / aspect;

            if (finalH > container.clientHeight) {
                finalH = container.clientHeight;
                finalW = finalH * aspect;
            }

            canvas.width = w; // D√πng k√≠ch th∆∞·ªõc th·∫≠t c·ªßa ·∫£nh ƒë·ªÉ v·∫Ω n√©t nh·∫•t
            canvas.height = h;
            
            // Mask canvas c≈©ng ph·∫£i b·∫±ng k√≠ch th∆∞·ªõc th·∫≠t
            maskCanvas.width = w;
            maskCanvas.height = h;
            
            // Set k√≠ch th∆∞·ªõc hi·ªÉn th·ªã CSS
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.objectFit = 'contain';
        }

        function toggleTools(enable) {
            document.getElementById('addPathButton').disabled = !enable;
            document.getElementById('addVectorFieldButton').disabled = !enable;
            document.getElementById('startStopSim').disabled = !enable;
        }

        // --- C√îNG C·ª§ V·∫º & T∆Ø∆†NG T√ÅC ---
        
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            // T√≠nh to√°n t·ª∑ l·ªá scale gi·ªØa k√≠ch th∆∞·ªõc hi·ªÉn th·ªã v√† k√≠ch th∆∞·ªõc th·ª±c t·∫ø
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        // Setup Event Listeners v·∫Ω
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', drawMove);
        canvas.addEventListener('mouseup', endDrawing);

        document.getElementById('addPathButton').addEventListener('click', () => setMode('line'));
        document.getElementById('addVectorFieldButton').addEventListener('click', () => setMode('vector'));
        document.getElementById('resetPaths').addEventListener('click', resetAll);

        function setMode(mode) {
            appState.mode = mode;
            appState.isDrawing = false;
            canvas.classList.remove('drawing-mode');
            if (mode !== 'idle') canvas.classList.add('drawing-mode');
            
            if (mode === 'line') statusMsg.textContent = "‚úèÔ∏è ƒêang ch·ªçn v·∫Ω Line: K√©o chu·ªôt ƒë·ªÉ t·∫°o ƒë∆∞·ªùng d·∫´n.";
            if (mode === 'vector') statusMsg.textContent = "üñåÔ∏è ƒêang ch·ªçn Vector Zone: V·∫Ω m·ªôt v√≤ng kh√©p k√≠n ƒë·ªÉ t·∫°o v√πng ch·ª©a h·∫°t.";
        }

        function startDrawing(e) {
            if (appState.mode === 'idle') return;
            const pos = getMousePos(e);
            appState.isDrawing = true;
            
            if (appState.mode === 'line') {
                currentPath = { type: 'line', points: [pos] };
            } else if (appState.mode === 'vector') {
                currentPath = { 
                    type: 'vector', 
                    points: [pos], // D√πng ƒë·ªÉ x√°c ƒë·ªãnh h∆∞·ªõng (ƒëi·ªÉm ƒë·∫ßu -> ƒëi·ªÉm cu·ªëi)
                    drawPoints: [pos] // D√πng ƒë·ªÉ v·∫Ω h√¨nh d·∫°ng
                };
                // B·∫Øt ƒë·∫ßu v·∫Ω mask m·ªõi
                maskCtx.beginPath();
                maskCtx.moveTo(pos.x, pos.y);
            }
        }

        function drawMove(e) {
            if (!appState.isDrawing) return;
            const pos = getMousePos(e);

            if (appState.mode === 'line') {
                currentPath.points.push(pos);
            } else if (appState.mode === 'vector') {
                currentPath.drawPoints.push(pos);
                maskCtx.lineTo(pos.x, pos.y); // Ch·ªâ v·∫Ω n√©t tr√™n mask t·∫°m th·ªùi
            }
            drawMain(); // Redraw UI ƒë·ªÉ th·∫•y n√©t ƒëang v·∫Ω
        }

        function endDrawing(e) {
            if (!appState.isDrawing) return;
            appState.isDrawing = false;
            const pos = getMousePos(e);

            if (appState.mode === 'line') {
                if (currentPath.points.length > 5) {
                    calculateLineLength(currentPath);
                    initParticles(currentPath);
                    appState.paths.push(currentPath);
                }
            } else if (appState.mode === 'vector') {
                // K·∫øt th√∫c v√πng vector: ƒê√≥ng path v√† fill
                maskCtx.lineTo(pos.x, pos.y);
                maskCtx.closePath();
                // L∆∞u √Ω: M·ªói path vector s·∫Ω c√≥ mask ri√™ng ho·∫∑c d√πng chung. 
                // ƒê·ªÉ ƒë∆°n gi·∫£n, ta s·∫Ω v·∫Ω v√πng n√†y l√™n maskCanvas ch√≠nh v·ªõi m√†u tr·∫Øng (visible)
                maskCtx.fillStyle = '#FFFFFF';
                maskCtx.fill();
                
                // L∆∞u ƒëi·ªÉm cu·ªëi ƒë·ªÉ t√≠nh vector h∆∞·ªõng
                currentPath.points.push(pos);
                
                // L∆∞u bounding box ƒë·ªÉ t·ªëi ∆∞u vi·ªác spawn h·∫°t
                calculateBounds(currentPath);
                
                // L∆∞u d·ªØ li·ªáu pixel c·ªßa mask v√πng n√†y ƒë·ªÉ ki·ªÉm tra va ch·∫°m sau n√†y
                // (Th·ª±c t·∫ø ta ki·ªÉm tra tr·ª±c ti·∫øp tr√™n maskCanvas global)
                
                initParticles(currentPath);
                appState.paths.push(currentPath);
            }

            currentPath = null;
            drawMain();
            document.getElementById('generateGif').disabled = false;
        }

        function resetAll() {
            appState.paths = [];
            appState.particles = [];
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            drawMain();
        }

        // --- LOGIC T√çNH TO√ÅN PATH & H·∫†T ---

        function calculateLineLength(path) {
            let total = 0;
            path.dists = [0];
            for(let i=1; i<path.points.length; i++){
                const d = Math.hypot(path.points[i].x - path.points[i-1].x, path.points[i].y - path.points[i-1].y);
                total += d;
                path.dists.push(total);
            }
            path.length = total;
        }

        function calculateBounds(path) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.drawPoints.forEach(p => {
                if(p.x < minX) minX = p.x;
                if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y;
                if(p.y > maxY) maxY = p.y;
            });
            path.bounds = { minX, maxX, minY, maxY, w: maxX-minX, h: maxY-minY };
            
            // T√≠nh h∆∞·ªõng ch√≠nh d·ª±a tr√™n ƒëi·ªÉm ƒë·∫ßu v√† ƒëi·ªÉm cu·ªëi
            const pStart = path.points[0];
            const pEnd = path.points[path.points.length-1]; // ƒêi·ªÉm nh·∫£ chu·ªôt
            const dx = pEnd.x - pStart.x;
            const dy = pEnd.y - pStart.y;
            const mag = Math.hypot(dx, dy) || 1;
            path.direction = { x: dx/mag, y: dy/mag };
        }

        function initParticles(path) {
            const density = parseFloat(document.getElementById('intensityControl').value);
            const count = Math.floor(CONFIG.maxParticles * density / appState.paths.length) || 50;

            for(let i=0; i<count; i++) {
                spawnParticle(path);
            }
        }

        function spawnParticle(path, forceReset = false) {
            let p = {
                pathIndex: appState.paths.indexOf(path),
                sizeScale: 0.5 + Math.random(),
                rotation: Math.random() * Math.PI * 2,
                speedVar: 0.8 + Math.random() * 0.4
            };

            if (path.type === 'line') {
                p.t = Math.random(); // V·ªã tr√≠ tr√™n ƒë∆∞·ªùng (0-1)
                p.offset = (Math.random() - 0.5) * 10; // L·ªách sang 2 b√™n
            } else {
                // Vector: Spawn ng·∫´u nhi√™n trong bounding box, check mask
                let safe = 0;
                do {
                    p.x = path.bounds.minX + Math.random() * path.bounds.w;
                    p.y = path.bounds.minY + Math.random() * path.bounds.h;
                    safe++;
                } while (!isPointInMask(p.x, p.y) && safe < 50);
            }
            
            if (forceReset) return p;
            appState.particles.push(p);
        }

        function isPointInMask(x, y) {
            // Ki·ªÉm tra pixel t·∫°i x,y tr√™n maskCanvas c√≥ ƒë∆∞·ª£c fill m√†u kh√¥ng
            // ƒê·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng, ta kh√¥ng g·ªçi getImageData li√™n t·ª•c.
            // Trong th·ª±c t·∫ø n√™n cache ImageData, nh∆∞ng ·ªü ƒë√¢y demo ta d√πng maskCtx.isPointInPath
            // Tuy nhi√™n v√¨ ta v·∫Ω fill l√™n canvas, c√°ch t·ªët nh·∫•t l√† check pixel alpha > 0
            // *L∆∞u √Ω*: getImageData r·∫•t ch·∫≠m n·∫øu g·ªçi 60fps x n particles.
            // Gi·∫£i ph√°p: Ch·ªâ check khi spawn. Khi di chuy·ªÉn, n·∫øu ra ngo√†i th√¨ respawn.
            
            // ·ªû phi√™n b·∫£n n√†y, m√¨nh s·∫Ω d√πng getImageData 1 l·∫ßn cho bounding box ho·∫∑c ch·∫•p nh·∫≠n sai s·ªë h√¨nh ch·ªØ nh·∫≠t cho nh·∫π, 
            // ho·∫∑c check tr·ª±c ti·∫øp path vector n·∫øu v·∫Ω ph·ª©c t·∫°p.
            // ƒê·ªÉ ƒë∆°n gi·∫£n v√† "x·ªãn" nh∆∞ y√™u c·∫ßu: d√πng thu·∫≠t to√°n Ray Casting ho·∫∑c check pixel.
            // ·ªû ƒë√¢y m√¨nh d√πng c∆° ch·∫ø ƒë∆°n gi·∫£n: Check bounds (ƒë√£ c√≥) -> N·∫øu ok th√¨ coi nh∆∞ ok (ch·∫•p nh·∫≠n sai s·ªë ·ªü g√≥c) ƒë·ªÉ m∆∞·ª£t.
            // N·∫øu mu·ªën ch√≠nh x√°c tuy·ªát ƒë·ªëi theo h√¨nh v·∫Ω tay:
            const pixel = maskCtx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
            return pixel[3] > 0; // Alpha > 0
        }

        // --- RENDER LOOP ---

        document.getElementById('startStopSim').addEventListener('click', () => {
            appState.isSimulating = !appState.isSimulating;
            const btn = document.getElementById('startStopSim');
            if (appState.isSimulating) {
                btn.textContent = "‚è∏ T·∫†M D·ª™NG";
                btn.classList.remove('bg-green-600');
                btn.classList.add('bg-red-600');
                animate();
            } else {
                btn.textContent = "‚ñ∂ TI·∫æP T·ª§C";
                btn.classList.remove('bg-red-600');
                btn.classList.add('bg-green-600');
                cancelAnimationFrame(animationId);
            }
        });

        function animate(timestamp) {
            if (!appState.isSimulating) return;
            
            // Qu·∫£n l√Ω th·ªùi gian
            if (!appState.lastFrameTime) appState.lastFrameTime = timestamp;
            const dt = timestamp - appState.lastFrameTime;
            appState.lastFrameTime = timestamp;
            appState.simTime += dt;

            updateParticles(dt);
            drawMain();
            
            animationId = requestAnimationFrame(animate);
        }

        function updateParticles(dt) {
            const baseSpeed = parseFloat(document.getElementById('speedControl').value) * CONFIG.particleSpeedBase;
            const vectorSpeed = baseSpeed * CONFIG.vectorSpeedMult;

            appState.particles.forEach(p => {
                const path = appState.paths[p.pathIndex];
                if (!path) return;

                if (path.type === 'line') {
                    p.t += baseSpeed * p.speedVar;
                    if (p.t > 1) p.t = 0;
                } else {
                    // Vector movement
                    p.x += path.direction.x * vectorSpeed * p.speedVar;
                    p.y += path.direction.y * vectorSpeed * p.speedVar;

                    // N·∫øu ra kh·ªèi bounds ho·∫∑c ra kh·ªèi v√πng v·∫Ω -> Respawn
                    if (p.x < path.bounds.minX || p.x > path.bounds.maxX || 
                        p.y < path.bounds.minY || p.y > path.bounds.maxY ||
                        !isPointInMask(p.x, p.y)) {
                            // Respawn ph√≠a ƒë·ªëi di·ªán ho·∫∑c random
                            let safe = 0;
                            do {
                                p.x = path.bounds.minX + Math.random() * path.bounds.w;
                                p.y = path.bounds.minY + Math.random() * path.bounds.h;
                                safe++;
                            } while (!isPointInMask(p.x, p.y) && safe < 10);
                    }
                }
            });
        }

        function drawMain() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω n·ªÅn (GIF ho·∫∑c ·∫¢nh tƒ©nh)
            if (appState.bgType === 'image' && appState.bgImage) {
                ctx.drawImage(appState.bgImage, 0, 0, canvas.width, canvas.height);
            } else if (appState.bgType === 'gif' && appState.bgGifFrames.length > 0) {
                // T√≠nh to√°n frame hi·ªán t·∫°i d·ª±a tr√™n th·ªùi gian
                const totalDuration = appState.bgGifDuration || 1000;
                const timeMod = appState.simTime % totalDuration;
                let t = 0;
                let currentFrame = appState.bgGifFrames[0];
                
                for (let f of appState.bgGifFrames) {
                    t += f.delay;
                    if (t >= timeMod) {
                        currentFrame = f;
                        break;
                    }
                }
                
                // V·∫Ω frame GIF
                // Note: GIF frames th∆∞·ªùng c√≥ k√≠ch th∆∞·ªõc kh√°c nhau (optimization), c·∫ßn v·∫Ω ch·ªìng l√™n frame tr∆∞·ªõc (disposal method).
                // Nh∆∞ng ·ªü ƒë√¢y ƒë·ªÉ ƒë∆°n gi·∫£n v√† hi·ªáu nƒÉng, ta v·∫Ω tr·ª±c ti·∫øp bitmap frame.
                // N·∫øu GIF c√≥ background transparent, c·∫ßn clearRect ho·∫∑c v·∫Ω ƒë√® l√™n canvas ƒë·ªám.
                // ·ªû ƒë√¢y ta v·∫Ω ƒë√® l√™n v·ªã tr√≠ dims.
                ctx.drawImage(currentFrame.bitmap, currentFrame.dims.left, currentFrame.dims.top);
            }

            // 2. V·∫Ω Path (Khi ƒëang v·∫Ω ho·∫∑c debugging)
            if (appState.isDrawing && currentPath) {
                ctx.beginPath();
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                if (currentPath.type === 'line') {
                    ctx.moveTo(currentPath.points[0].x, currentPath.points[0].y);
                    for (let p of currentPath.points) ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                } else {
                    // V·∫Ω v√πng ƒëang ch·ªçn
                    ctx.moveTo(currentPath.drawPoints[0].x, currentPath.drawPoints[0].y);
                    for (let p of currentPath.drawPoints) ctx.lineTo(p.x, p.y);
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // V·∫Ω c√°c v√πng ƒë√£ t·∫°o (m·ªù m·ªù ƒë·ªÉ bi·∫øt v·ªã tr√≠)
            appState.paths.forEach(path => {
                if (path.type === 'vector') {
                    ctx.save();
                    ctx.globalAlpha = 0.1;
                    ctx.strokeStyle = 'cyan';
                    ctx.beginPath();
                    ctx.rect(path.bounds.minX, path.bounds.minY, path.bounds.w, path.bounds.h);
                    ctx.stroke();
                    ctx.restore();
                }
            });

            // 3. V·∫Ω H·∫°t
            const pSize = parseInt(document.getElementById('sizeControl').value);
            appState.particles.forEach(p => {
                let x, y;
                const path = appState.paths[p.pathIndex];
                
                if (path.type === 'line') {
                    // L·∫•y v·ªã tr√≠ tr√™n line
                    const targetDist = p.t * path.length;
                    // T√¨m ƒëo·∫°n th·∫≥ng ch·ª©a ƒëi·ªÉm n√†y
                    let distAcc = 0;
                    for(let i=1; i<path.dists.length; i++) {
                        if (path.dists[i] >= targetDist) {
                            const segmentLen = path.dists[i] - path.dists[i-1];
                            const segmentT = (targetDist - path.dists[i-1]) / segmentLen;
                            const p1 = path.points[i-1];
                            const p2 = path.points[i];
                            x = p1.x + (p2.x - p1.x) * segmentT;
                            y = p1.y + (p2.y - p1.y) * segmentT;
                            
                            // Offset vu√¥ng g√≥c ƒë·ªÉ t·∫°o ƒë·ªô d√†y d√≤ng ch·∫£y
                            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                            x += Math.sin(angle) * p.offset;
                            y -= Math.cos(angle) * p.offset;
                            break;
                        }
                    }
                } else {
                    x = p.x;
                    y = p.y;
                }

                if (x !== undefined) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(p.rotation);
                    const size = pSize * p.sizeScale;
                    
                    if (appState.materialImage) {
                        ctx.drawImage(appState.materialImage, -size/2, -size/2, size, size);
                    } else {
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(0, 0, size/3, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            });
        }

        // --- XU·∫§T GIF (N√ÇNG CAO) ---
        
        document.getElementById('generateGif').addEventListener('click', () => {
            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: canvas.width,
                height: canvas.height,
                workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.worker.js' // C·∫ßn load worker ƒë√∫ng
            });

            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = "ƒêang render GIF (0%)...";

            // T·∫°m d·ª´ng m√¥ ph·ªèng m√†n h√¨nh ƒë·ªÉ render
            const wasSimulating = appState.isSimulating;
            appState.isSimulating = false;
            cancelAnimationFrame(animationId);

            // C·∫•u h√¨nh render
            const fps = 20;
            const durationSec = 3; // Xu·∫•t 3 gi√¢y
            const totalFrames = fps * durationSec;
            const stepTime = 1000 / fps; // ms per frame

            // Clone state ƒë·ªÉ ch·∫°y th·ª≠
            let tempTime = appState.simTime;
            
            // Loop render t·ª´ng frame
            setTimeout(async () => {
                for (let i = 0; i < totalFrames; i++) {
                    tempTime += stepTime;
                    
                    // 1. C·∫≠p nh·∫≠t v·ªã tr√≠ h·∫°t ·∫£o
                    updateParticles(stepTime);

                    // 2. V·∫Ω Frame n·ªÅn (GIF ho·∫∑c ·∫¢nh) v√†o th·ªùi ƒëi·ªÉm tempTime
                    // Hack: G·ªçi h√†m drawMain nh∆∞ng √©p simTime t·∫°m th·ªùi
                    const realTime = appState.simTime;
                    appState.simTime = tempTime;
                    drawMain(); 
                    appState.simTime = realTime; // Restore

                    // 3. Add frame
                    gif.addFrame(ctx, {copy: true, delay: stepTime});
                    
                    loadingText.textContent = `ƒêang render GIF (${Math.round(i/totalFrames*100)}%)...`;
                    // Cho UI th·ªü
                    await new Promise(r => setTimeout(r, 0));
                }

                loadingText.textContent = "ƒêang m√£ h√≥a GIF...";
                gif.on('finished', function(blob) {
                    loadingOverlay.classList.add('hidden');
                    const url = URL.createObjectURL(blob);
                    document.getElementById('gifPreview').src = url;
                    document.getElementById('gifDownloadLink').href = url;
                    document.getElementById('gifPreviewArea').classList.remove('hidden');
                    
                    if (wasSimulating) document.getElementById('startStopSim').click();
                });

                gif.render();
            }, 100);
        });

    </script>
</body>
</html>
