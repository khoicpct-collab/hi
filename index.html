<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FINAL FIX - M√¥ Ph·ªèng D√≤ng Ch·∫£y V·∫≠t Li·ªáu Tr√™n Video</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.js"></script>
    <style>
        .drawing-mode { cursor: crosshair !important; }
        .flow-container { background-color: #f0f4f8; min-height: 100vh; font-family: 'Segoe UI', sans-serif; }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: #4f46e5; border-radius: 50%; cursor: pointer;
            margin-top: -7px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #cbd5e1; border-radius: 2px;
        }
        .header-bg {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: white; padding: 1.5rem 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="flow-container">

    <video id="bgVideoElement" style="display:none;" loop muted></video>

    <div class="header-bg mb-6">
        <div class="max-w-7xl mx-auto px-6">
            <h1 class="text-3xl font-bold">M√î PH·ªéNG D√íNG CH·∫¢Y TR√äN VIDEO (B·∫¢N FINAL FIX)</h1>
            <p class="text-gray-400 text-sm mt-1">H·ªó tr·ª£ Video (N·ªÅn ƒê·ªông) v√† ·∫¢nh Tƒ©nh/GIF (N·ªÅn Tƒ©nh)</p>
        </div>
    </div>
    
    <div class="max-w-7xl mx-auto px-4 pb-10">
        <div class="flex flex-col lg:flex-row gap-6">

            <div class="lg:w-1/4 space-y-5 p-5 bg-white rounded-xl shadow-lg h-fit order-2 lg:order-1">
                
                <div class="space-y-3 border-b pb-4">
                    <p class="text-xs font-bold text-gray-400 uppercase">1. Upload File</p>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-1">Video N·ªÅn / ·∫¢nh Tƒ©nh / GIF</label>
                        <input type="file" id="baseImageUpload" accept="video/mp4, video/webm, image/png, image/jpeg, image/gif" class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer">
                    </div>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-1">V·∫≠t Li·ªáu (·∫¢nh tƒ©nh)</label>
                        <input type="file" id="materialImageUpload" accept="image/*" class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-pink-50 file:text-pink-700 hover:file:bg-pink-100 cursor-pointer">
                    </div>
                </div>

                <div class="space-y-2 border-b pb-4">
                    <p class="text-xs font-bold text-gray-400 uppercase">2. C√¥ng c·ª•</p>
                    <button id="btnLine" disabled class="w-full py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded text-sm transition disabled:opacity-50 flex items-center justify-center gap-2">
                        <span>‚úèÔ∏è</span> V·∫Ω ƒê∆∞·ªùng D·∫´n (Line)
                    </button>
                    <button id="btnVector" disabled class="w-full py-2 bg-cyan-600 hover:bg-cyan-700 text-white font-bold rounded text-sm transition disabled:opacity-50 flex items-center justify-center gap-2">
                        <span>üñåÔ∏è</span> V·∫Ω V√πng T·ª± Do (Area)
                    </button>
                    <button id="btnReset" class="w-full py-2 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded text-sm transition">
                        X√≥a T·∫•t C·∫£
                    </button>
                </div>

                <div class="space-y-4 border-b pb-4">
                    <p class="text-xs font-bold text-gray-400 uppercase">3. Th√¥ng s·ªë</p>
                    <div>
                        <div class="flex justify-between text-xs"><span>T·ªëc ƒë·ªô</span><span id="valSpeed" class="font-bold text-indigo-600">5</span></div>
                        <input type="range" id="rngSpeed" min="1" max="20" value="5" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs"><span>M·∫≠t ƒë·ªô</span><span id="valDensity" class="font-bold text-indigo-600">80%</span></div>
                        <input type="range" id="rngDensity" min="0.1" max="1.0" value="0.8" step="0.05" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs"><span>K√≠ch th∆∞·ªõc h·∫°t</span><span id="valSize" class="font-bold text-indigo-600">24px</span></div>
                         <input type="range" id="rngSize" min="5" max="60" value="24" class="w-full">
                    </div>
                </div>

                <div class="space-y-2">
                    <button id="btnSimulate" disabled class="w-full py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded shadow transition disabled:opacity-50">
                        ‚ñ∂ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG
                    </button>
                    <button id="btnExport" disabled class="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded shadow transition disabled:opacity-50">
                        üé¨ Xu·∫•t File GIF
                    </button>
                </div>
            </div>

            <div class="lg:w-3/4 relative order-1 lg:order-2">
                 <div id="msgStatus" class="mb-2 text-center text-sm font-semibold text-indigo-800 bg-indigo-100 p-2 rounded">
                    üëã Vui l√≤ng t·∫£i l√™n video ho·∫∑c ·∫£nh n·ªÅn ƒë·ªÉ b·∫Øt ƒë·∫ßu.
                </div>

                <div class="relative border-2 border-dashed border-gray-300 rounded-xl overflow-hidden bg-white shadow-inner flex items-center justify-center" style="height: 70vh;">
                    <canvas id="mainCanvas" class="absolute inset-0 w-full h-full"></canvas>
                    <div id="txtPlaceholder" class="text-gray-400 pointer-events-none">Khu v·ª±c hi·ªÉn th·ªã</div>
                    
                    <div id="loader" class="absolute inset-0 bg-white/90 z-50 flex flex-col items-center justify-center hidden">
                        <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-500 border-t-transparent mb-3"></div>
                        <span id="loaderText" class="text-indigo-700 font-medium animate-pulse">ƒêang x·ª≠ l√Ω...</span>
                    </div>
                </div>

                <div id="previewArea" class="hidden mt-4 p-4 bg-white rounded-xl shadow border text-center">
                    <h3 class="font-bold text-gray-700 mb-2">K·∫øt qu·∫£ Xu·∫•t File</h3>
                    <img id="imgResult" class="max-w-full h-auto mx-auto rounded border shadow-sm max-h-96">
                    <a id="lnkDownload" download="ket_qua_mo_phong.gif" class="inline-block mt-3 py-2 px-6 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700 cursor-pointer">
                        üì• T·∫£i Xu·ªëng
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * 1. C·∫§U H√åNH & STATE
         */
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');

        const bgVideoElement = document.getElementById('bgVideoElement');

        let state = {
            isSimulating: false,
            mode: 'idle', 
            isDrawing: false,
            
            bgType: 'none', // none, image, video
            bgImage: null,   // D√πng cho ·∫£nh tƒ©nh (bao g·ªìm c·∫£ GIF/PNG/JPG)
            
            materialImage: null,
            paths: [],
            particles: [],
            
            time: 0,
            lastFrameTime: 0
        };

        let currentPath = null;
        let animFrameId = null;

        const ui = {
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loaderText'),
            msg: document.getElementById('msgStatus'),
            btnLine: document.getElementById('btnLine'),
            btnVector: document.getElementById('btnVector'),
            btnSim: document.getElementById('btnSimulate'),
            btnExport: document.getElementById('btnExport'),
            placeholder: document.getElementById('txtPlaceholder')
        };

        // --- 2. X·ª¨ L√ù UPLOAD (H·ªñ TR·ª¢ VIDEO & IMAGE/GIF AN TO√ÄN) ---

        document.getElementById('baseImageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            ui.loader.classList.remove('hidden');
            ui.loaderText.textContent = "ƒêang t·∫£i file...";
            ui.placeholder.classList.add('hidden');
            
            try {
                if (file.type.startsWith('video/')) {
                    // --- X·ª≠ l√Ω Video (N·ªÅn ƒë·ªông) ---
                    bgVideoElement.src = URL.createObjectURL(file);
                    await new Promise(resolve => bgVideoElement.onloadedmetadata = resolve); 
                    
                    resizeCanvas(bgVideoElement.videoWidth, bgVideoElement.videoHeight);
                    
                    await bgVideoElement.play().catch(e => {
                        console.error("L·ªói Playback Video (th∆∞·ªùng do kh√¥ng ƒë∆∞·ª£c ph√©p t·ª± ƒë·ªông ph√°t):", e);
                    }); 
                    
                    state.bgType = 'video';
                    state.bgImage = null; 
                    state.time = 0;
                    
                    ui.msg.textContent = `‚úÖ ƒê√£ t·∫£i Video. B·∫•m ‚ñ∂ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG ƒë·ªÉ ch·∫°y n·ªÅn ƒë·ªông!`;
                    
                } else if (file.type.startsWith('image/')) {
                    // --- X·ª≠ l√Ω ·∫¢nh Tƒ©nh (Bao g·ªìm c·∫£ GIF) ---
                    bgVideoElement.pause();
                    bgVideoElement.src = ""; // Clear video source
                    
                    const img = new Image();
                    img.src = URL.createObjectURL(file);
                    await new Promise(resolve => img.onload = resolve);
                    
                    state.bgImage = await createImageBitmap(img); 
                    resizeCanvas(img.naturalWidth, img.naturalHeight);
                    state.bgType = 'image';
                    
                    if (file.type === 'image/gif') {
                        ui.msg.textContent = "‚ö†Ô∏è ƒê√£ t·∫£i GIF. Do v·∫•n ƒë·ªÅ t∆∞∆°ng th√≠ch, GIF s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã nh∆∞ ·∫¢nh Tƒ©nh.";
                    } else {
                        ui.msg.textContent = "‚úÖ ƒê√£ t·∫£i ·∫£nh n·ªÅn tƒ©nh. S·∫µn s√†ng v·∫Ω.";
                    }
                } else {
                    throw new Error("ƒê·ªãnh d·∫°ng file kh√¥ng h·ªó tr·ª£.");
                }

                enableTools(true);
                // B·∫Øt ƒë·∫ßu loop ngay n·∫øu l√† video, ho·∫∑c n·∫øu ƒëang m√¥ ph·ªèng.
                if (state.bgType === 'video' || state.isSimulating) {
                     if (!state.isSimulating) {
                        state.isSimulating = true;
                        ui.btnSim.textContent = "‚è∏ T·∫†M D·ª™NG";
                     }
                     loop();
                } else {
                    drawMain();
                }

            } catch (err) {
                console.error(err);
                alert("Kh√¥ng th·ªÉ ƒë·ªçc file n√†y. Vui l√≤ng th·ª≠ file MP4/WebM ho·∫∑c ·∫£nh JPG/PNG/GIF kh√°c.");
                ui.msg.textContent = "‚ùå L·ªói ƒë·ªçc file. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng.";
            } finally {
                ui.loader.classList.add('hidden');
            }
        });

        // T·∫£i v·∫≠t li·ªáu (Gi·ªØ nguy√™n)
        document.getElementById('materialImageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(resolve => img.onload = resolve);
                state.materialImage = await createImageBitmap(img);
                drawMain();
            }
        });

        // --- 3. LOGIC H·ªÜ TH·ªêNG & V·∫º --- (Gi·ªØ nguy√™n)

        function resizeCanvas(w, h) {
            const parent = canvas.parentElement;
            const aspect = w / h;
            
            canvas.width = w;
            canvas.height = h;
            maskCanvas.width = w;
            maskCanvas.height = h;

            if (parent.clientWidth / parent.clientHeight > aspect) {
                canvas.style.height = '100%';
                canvas.style.width = 'auto';
            } else {
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            }
        }

        function enableTools(enable) {
            ui.btnLine.disabled = !enable;
            ui.btnVector.disabled = !enable;
            ui.btnSim.disabled = !enable;
        }

        ui.btnLine.addEventListener('click', () => setMode('line'));
        ui.btnVector.addEventListener('click', () => setMode('vector'));
        document.getElementById('btnReset').addEventListener('click', () => {
            state.paths = [];
            state.particles = [];
            maskCtx.clearRect(0,0,maskCanvas.width, maskCanvas.height);
            drawMain();
        });

        function setMode(m) {
            state.mode = m;
            canvas.classList.toggle('drawing-mode', m !== 'idle');
            ui.msg.textContent = m === 'line' 
                ? "‚úèÔ∏è V·∫Ω Line: K√©o chu·ªôt t·∫°o ƒë∆∞·ªùng d·∫´n." 
                : "üñåÔ∏è V·∫Ω V√πng: V·∫Ω v√≤ng tr√≤n kh√©p k√≠n ƒë·ªÉ ch·ª©a h·∫°t.";
        }

        const getPos = (e) => {
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            return {
                x: (e.clientX - r.left) * scaleX,
                y: (e.clientY - r.top) * scaleY
            };
        };
        
        canvas.addEventListener('mousedown', e => {
            if(state.mode === 'idle') return;
            state.isDrawing = true;
            const p = getPos(e);
            
            if (state.mode === 'line') {
                currentPath = { type: 'line', points: [p] };
            } else {
                currentPath = { type: 'vector', points: [p], drawPoints: [p] };
                maskCtx.beginPath();
                maskCtx.moveTo(p.x, p.y);
            }
        });

        canvas.addEventListener('mousemove', e => {
            if(!state.isDrawing) return;
            const p = getPos(e);
            if(state.mode === 'line') {
                currentPath.points.push(p);
            } else {
                currentPath.drawPoints.push(p);
                maskCtx.lineTo(p.x, p.y);
            }
            drawMain();
        });

        canvas.addEventListener('mouseup', e => {
            if(!state.isDrawing) return;
            state.isDrawing = false;
            
            if(state.mode === 'line') {
                if(currentPath.points.length > 5) {
                    initLinePath(currentPath);
                    state.paths.push(currentPath);
                }
            } else {
                const p = getPos(e);
                maskCtx.lineTo(p.x, p.y);
                maskCtx.closePath();
                maskCtx.fillStyle = '#ffffff'; 
                maskCtx.fill();
                
                currentPath.points.push(p); 
                calcVectorBounds(currentPath);
                initParticles(currentPath);
                state.paths.push(currentPath);
            }
            currentPath = null;
            ui.btnExport.disabled = false;
            drawMain();
        });

        function initLinePath(path) {
            let total = 0;
            path.dists = [0];
            for(let i=1; i<path.points.length; i++){
                total += Math.hypot(path.points[i].x - path.points[i-1].x, path.points[i].y - path.points[i-1].y);
                path.dists.push(total);
            }
            path.length = total;
            initParticles(path);
        }

        function calcVectorBounds(path) {
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            path.drawPoints.forEach(p => {
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
            });
            path.bounds = { minX, maxX, minY, maxY, w: maxX-minX, h: maxY-minY };
            
            const p1 = path.points[0];
            const p2 = path.points[path.points.length-1];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const mag = Math.hypot(dx, dy) || 1;
            path.dir = { x: dx/mag, y: dy/mag };
        }

        function initParticles(path) {
            const density = parseFloat(document.getElementById('rngDensity').value);
            const count = 100 * density;
            for(let i=0; i<count; i++) spawnParticle(path);
        }

        function spawnParticle(path) {
            let p = {
                pathIdx: state.paths.indexOf(path),
                sizeVar: 0.5 + Math.random(),
                speedVar: 0.8 + Math.random()*0.4,
                rot: Math.random() * 6.28
            };

            if(path.type === 'line') {
                p.t = Math.random();
                p.offset = (Math.random()-0.5) * 10;
            } else {
                let ok = false;
                for(let k=0; k<10; k++){
                    p.x = path.bounds.minX + Math.random()*path.bounds.w;
                    p.y = path.bounds.minY + Math.random()*path.bounds.h;
                    if(p.x >= path.bounds.minX && p.x <= path.bounds.maxX && p.y >= path.bounds.minY && p.y <= path.bounds.maxY) { 
                        ok = true; break; 
                    }
                }
                if(!ok) { p.x = path.bounds.minX; p.y = path.bounds.minY; }
            }
            state.particles.push(p);
        }

        // --- UPDATE, DRAW v√† EXPORT --- (Gi·ªØ nguy√™n logic m√¥ ph·ªèng v√† xu·∫•t GIF)

        ui.btnSim.addEventListener('click', () => {
            state.isSimulating = !state.isSimulating;
            ui.btnSim.textContent = state.isSimulating ? "‚è∏ T·∫†M D·ª™NG" : "‚ñ∂ TI·∫æP T·ª§C";
            
            if (state.bgType === 'video') {
                state.isSimulating ? bgVideoElement.play() : bgVideoElement.pause();
            }

            if(state.isSimulating) loop();
            else cancelAnimationFrame(animFrameId);
        });

        function loop(timestamp) {
            if(!state.isSimulating) return;
            if(!timestamp) timestamp = performance.now();
            
            const dt = timestamp - (state.lastFrameTime || timestamp);
            state.lastFrameTime = timestamp;
            state.time += dt;

            update(dt);
            drawMain();
            animFrameId = requestAnimationFrame(loop);
        }

        function update(dt) {
            const speed = parseFloat(document.getElementById('rngSpeed').value) * 0.0005 * dt;
            
            state.particles.forEach(p => {
                const path = state.paths[p.pathIdx];
                if(!path) return;

                if(path.type === 'line') {
                    p.t += speed * p.speedVar;
                    if(p.t > 1) p.t = 0;
                } else {
                    const vectorSpeed = speed * 20;
                    p.x += path.dir.x * vectorSpeed * p.speedVar;
                    p.y += path.dir.y * vectorSpeed * p.speedVar;
                    
                    if(p.x < path.bounds.minX || p.x > path.bounds.maxX || 
                       p.y < path.bounds.minY || p.y > path.bounds.maxY) {
                        p.x = path.bounds.minX + Math.random()*path.bounds.w;
                        p.y = path.bounds.minY + Math.random()*path.bounds.h;
                    }
                }
            });
        }

        function drawMain() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω N·ªÅn
            if (state.bgType === 'video' && bgVideoElement.readyState > 1) { 
                ctx.drawImage(bgVideoElement, 0, 0, canvas.width, canvas.height);
            } 
            else if (state.bgType === 'image' && state.bgImage) {
                ctx.drawImage(state.bgImage, 0, 0, canvas.width, canvas.height);
            }

            // 2. V·∫Ω n√©t ƒëang v·∫Ω
            if (state.isDrawing && currentPath) {
                ctx.strokeStyle = 'yellow'; ctx.lineWidth = 2;
                ctx.beginPath();
                if(currentPath.type === 'line') {
                    ctx.moveTo(currentPath.points[0].x, currentPath.points[0].y);
                    currentPath.points.forEach(p => ctx.lineTo(p.x, p.y));
                } else {
                    ctx.moveTo(currentPath.drawPoints[0].x, currentPath.drawPoints[0].y);
                    currentPath.drawPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.fillStyle = 'rgba(0,255,255,0.2)'; ctx.fill();
                }
                ctx.stroke();
            }

            // 3. V·∫Ω H·∫°t
            const baseSize = parseInt(document.getElementById('rngSize').value);
            state.particles.forEach(p => {
                const path = state.paths[p.pathIdx];
                let x, y;
                
                if(path.type === 'line') {
                    const d = p.t * path.length;
                    for(let i=1; i<path.dists.length; i++){
                        if(path.dists[i] >= d) {
                            const segLen = path.dists[i] - path.dists[i-1];
                            const r = (d - path.dists[i-1]) / segLen;
                            const p1 = path.points[i-1];
                            const p2 = path.points[i];
                            x = p1.x + (p2.x - p1.x)*r;
                            y = p1.y + (p2.y - p1.y)*r;
                            
                            const ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
                            x += Math.sin(ang)*p.offset;
                            y -= Math.cos(ang)*p.offset;
                            break;
                        }
                    }
                } else {
                    x = p.x; y = p.y;
                }

                if(x !== undefined) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(p.rot);
                    const s = baseSize * p.sizeVar;
                    if(state.materialImage) {
                        ctx.drawImage(state.materialImage, -s/2, -s/2, s, s);
                    } else {
                        ctx.fillStyle = 'orange';
                        ctx.beginPath(); ctx.arc(0,0,s/3,0,6.28); ctx.fill();
                    }
                    ctx.restore();
                }
            });
        }

        ui.btnExport.addEventListener('click', async () => {
            if (state.bgType === 'none' || state.paths.length === 0) {
                 alert("Vui l√≤ng t·∫£i l√™n video/·∫£nh v√† v·∫Ω ƒë∆∞·ªùng d·∫´n m√¥ ph·ªèng tr∆∞·ªõc khi xu·∫•t file.");
                 return;
            }
            
            const isVideoExport = state.bgType === 'video';
            const gif = new GIF({
                workers: 2,
                quality: isVideoExport ? 5 : 10,
                width: canvas.width,
                height: canvas.height,
                workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.worker.js' 
            });

            ui.loader.classList.remove('hidden');
            ui.loaderText.textContent = "ƒêang render GIF...";
            
            const fps = 20;
            const dt = 1000 / fps;
            const totalSeconds = isVideoExport ? 3 : 2; // Xu·∫•t 3s cho video, 2s cho ·∫£nh tƒ©nh
            const totalFrames = totalSeconds * fps;
            
            const realTime = state.time;
            let wasPlaying = false;
            
            if(isVideoExport) {
                wasPlaying = !bgVideoElement.paused;
                bgVideoElement.pause();
            }

            for(let i=0; i<totalFrames; i++) {
                
                if (isVideoExport) {
                    const targetTime = (i * dt) / 1000;
                    // ƒê·∫£m b·∫£o th·ªùi gian l·∫∑p l·∫°i trong video duration
                    bgVideoElement.currentTime = targetTime % bgVideoElement.duration; 
                    
                    await new Promise(resolve => {
                        bgVideoElement.onseeked = resolve;
                        setTimeout(resolve, 30); 
                    });
                }
                
                state.time += dt;
                update(dt); 
                drawMain(); 
                gif.addFrame(ctx, {copy: true, delay: dt});
                
                ui.loaderText.textContent = `Rendering ${(i/totalFrames*100)|0}%`;
                await new Promise(r => setTimeout(r, 0));
            }

            state.time = realTime;
            
            if(isVideoExport) {
                if(wasPlaying) bgVideoElement.play();
                bgVideoElement.currentTime = realTime / 1000 % bgVideoElement.duration;
            }
            if (state.isSimulating) loop();


            ui.loaderText.textContent = "Encoding...";
            gif.on('finished', blob => {
                ui.loader.classList.add('hidden');
                const url = URL.createObjectURL(blob);
                document.getElementById('imgResult').src = url;
                document.getElementById('lnkDownload').href = url;
                document.getElementById('previewArea').classList.remove('hidden');
            });

            gif.render();
        });
        
        // Kh·ªüi t·∫°o ban ƒë·∫ßu
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
