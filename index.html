<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRO FIX - M√¥ Ph·ªèng D√≤ng Ch·∫£y V·∫≠t Li·ªáu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/gifuct-js@2.1.2/dist/gifuct-js.min.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.js"></script>
    <style>
        .drawing-mode { cursor: crosshair !important; }
        .flow-container { background-color: #f0f4f8; min-height: 100vh; font-family: 'Segoe UI', sans-serif; }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: #4f46e5; border-radius: 50%; cursor: pointer;
            margin-top: -7px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #cbd5e1; border-radius: 2px;
        }
        .header-bg {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: white; padding: 1.5rem 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="flow-container">

    <div class="header-bg mb-6">
        <div class="max-w-7xl mx-auto px-6">
            <h1 class="text-3xl font-bold">M√î PH·ªéNG D√íNG CH·∫¢Y (B·∫¢N FIX TRI·ªÜT ƒê·ªÇ)</h1>
            <p class="text-gray-400 text-sm mt-1">H·ªó tr·ª£ upload GIF (k·ªÉ c·∫£ GIF ph·ª©c t·∫°p) & V·∫Ω v√πng t·ª± do</p>
        </div>
    </div>
    
    <div class="max-w-7xl mx-auto px-4 pb-10">
        <div class="flex flex-col lg:flex-row gap-6">

            <div class="lg:w-1/4 space-y-5 p-5 bg-white rounded-xl shadow-lg h-fit order-2 lg:order-1">
                
                <div class="space-y-3 border-b pb-4">
                    <p class="text-xs font-bold text-gray-400 uppercase">1. Upload File</p>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-1">·∫¢nh N·ªÅn / GIF ƒê·ªông</label>
                        <input type="file" id="baseImageUpload" accept="image/png, image/jpeg, image/gif" class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer">
                    </div>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-1">V·∫≠t Li·ªáu (·∫¢nh tƒ©nh)</label>
                        <input type="file" id="materialImageUpload" accept="image/*" class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-pink-50 file:text-pink-700 hover:file:bg-pink-100 cursor-pointer">
                    </div>
                </div>

                <div class="space-y-2 border-b pb-4">
                    <p class="text-xs font-bold text-gray-400 uppercase">2. C√¥ng c·ª•</p>
                    <button id="btnLine" disabled class="w-full py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded text-sm transition disabled:opacity-50 flex items-center justify-center gap-2">
                        <span>‚úèÔ∏è</span> V·∫Ω ƒê∆∞·ªùng D·∫´n (Line)
                    </button>
                    <button id="btnVector" disabled class="w-full py-2 bg-cyan-600 hover:bg-cyan-700 text-white font-bold rounded text-sm transition disabled:opacity-50 flex items-center justify-center gap-2">
                        <span>üñåÔ∏è</span> V·∫Ω V√πng T·ª± Do (Area)
                    </button>
                    <button id="btnReset" class="w-full py-2 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded text-sm transition">
                        X√≥a T·∫•t C·∫£
                    </button>
                </div>

                <div class="space-y-4 border-b pb-4">
                    <p class="text-xs font-bold text-gray-400 uppercase">3. Th√¥ng s·ªë</p>
                    <div>
                        <div class="flex justify-between text-xs"><span>T·ªëc ƒë·ªô</span><span id="valSpeed" class="font-bold text-indigo-600">5</span></div>
                        <input type="range" id="rngSpeed" min="1" max="20" value="5" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs"><span>M·∫≠t ƒë·ªô</span><span id="valDensity" class="font-bold text-indigo-600">80%</span></div>
                        <input type="range" id="rngDensity" min="0.1" max="1.0" value="0.8" step="0.05" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs"><span>K√≠ch th∆∞·ªõc h·∫°t</span><span id="valSize" class="font-bold text-indigo-600">24px</span></div>
                         <input type="range" id="rngSize" min="5" max="60" value="24" class="w-full">
                    </div>
                </div>

                <div class="space-y-2">
                    <button id="btnSimulate" disabled class="w-full py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded shadow transition disabled:opacity-50">
                        ‚ñ∂ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG
                    </button>
                    <button id="btnExport" disabled class="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded shadow transition disabled:opacity-50">
                        üé¨ Xu·∫•t File GIF
                    </button>
                </div>
            </div>

            <div class="lg:w-3/4 relative order-1 lg:order-2">
                 <div id="msgStatus" class="mb-2 text-center text-sm font-semibold text-indigo-800 bg-indigo-100 p-2 rounded">
                    üëã Vui l√≤ng t·∫£i l√™n ·∫£nh n·ªÅn ƒë·ªÉ b·∫Øt ƒë·∫ßu.
                </div>

                <div class="relative border-2 border-dashed border-gray-300 rounded-xl overflow-hidden bg-white shadow-inner flex items-center justify-center" style="height: 70vh;">
                    <canvas id="mainCanvas" class="absolute inset-0 w-full h-full"></canvas>
                    <div id="txtPlaceholder" class="text-gray-400 pointer-events-none">Khu v·ª±c hi·ªÉn th·ªã</div>
                    
                    <div id="loader" class="absolute inset-0 bg-white/90 z-50 flex flex-col items-center justify-center hidden">
                        <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-500 border-t-transparent mb-3"></div>
                        <span id="loaderText" class="text-indigo-700 font-medium animate-pulse">ƒêang x·ª≠ l√Ω...</span>
                    </div>
                </div>

                <div id="previewArea" class="hidden mt-4 p-4 bg-white rounded-xl shadow border text-center">
                    <h3 class="font-bold text-gray-700 mb-2">K·∫øt qu·∫£ Xu·∫•t File</h3>
                    <img id="imgResult" class="max-w-full h-auto mx-auto rounded border shadow-sm max-h-96">
                    <a id="lnkDownload" download="ket_qua_mo_phong.gif" class="inline-block mt-3 py-2 px-6 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700 cursor-pointer">
                        üì• T·∫£i Xu·ªëng
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * 1. C·∫§U H√åNH & STATE
         */
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');

        let state = {
            isSimulating: false,
            mode: 'idle', // idle, line, vector
            isDrawing: false,
            
            bgType: 'none', // none, image, gif
            bgImage: null,   // D√πng cho ·∫£nh tƒ©nh ho·∫∑c fallback c·ªßa GIF
            bgGifFrames: [], 
            bgGifDuration: 0,
            
            materialImage: null,
            paths: [],
            particles: [],
            
            time: 0,
            lastFrameTime: 0
        };

        let currentPath = null;
        let animFrameId = null;

        const ui = {
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loaderText'),
            msg: document.getElementById('msgStatus'),
            btnLine: document.getElementById('btnLine'),
            btnVector: document.getElementById('btnVector'),
            btnSim: document.getElementById('btnSimulate'),
            btnExport: document.getElementById('btnExport'),
            placeholder: document.getElementById('txtPlaceholder')
        };

        // --- 2. X·ª¨ L√ù GIF N√ÇNG CAO & D·ª∞ PH√íNG (FIX L·ªñI UPLOAD) ---

        // H√†m parse GIF an to√†n
        const parseGif = (buffer) => {
            try {
                // S·ª≠ d·ª•ng h√†m gi·∫£i n√©n c·ªßa th∆∞ vi·ªán
                const gif = new GIF(buffer);
                return gif.decompressFrames(true);
            } catch (e) {
                console.warn("L·ªói khi gi·∫£i m√£ frame GIF, chuy·ªÉn sang ch·∫ø ƒë·ªô ·∫£nh tƒ©nh.", e);
                return null;
            }
        };

        // H√†m t·∫°o frames t·ª´ d·ªØ li·ªáu th√¥
        const createGifFrames = async (frames, width, height) => {
            const loadedFrames = [];
            let totalTime = 0;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // X√≥a frame c≈© ƒë·ªÉ x·ª≠ l√Ω disposal method
            tempCtx.clearRect(0, 0, width, height); 

            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                
                // 1. T·∫°o ImageData v√† ImageBitmap (V·∫Ω nhanh)
                const patchData = new ImageData(
                    new Uint8ClampedArray(frame.patch),
                    frame.dims.width,
                    frame.dims.height
                );
                const patchBitmap = await createImageBitmap(patchData);

                // 2. V·∫Ω patch l√™n canvas t·∫°m (ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng ƒë·ªÉ x·ª≠ l√Ω GIF transparent)
                // L∆∞u √Ω: GIF disposal method = 2 (restore to background) c·∫ßn th√™m logic. 
                // ·ªû ƒë√¢y, ta gi·∫£ ƒë·ªãnh ƒëa s·ªë l√† v·∫Ω ch·ªìng l√™n (draw over) ho·∫∑c clear to first frame/black.
                
                // C·∫≠p nh·∫≠t l·∫°i canvas t·∫°m
                tempCtx.drawImage(patchBitmap, frame.dims.left, frame.dims.top);

                // 3. L∆∞u l·∫°i tr·∫°ng th√°i ƒë·∫ßy ƒë·ªß c·ªßa frame n√†y
                const fullFrameBitmap = await createImageBitmap(tempCanvas);

                loadedFrames.push({
                    bitmap: fullFrameBitmap,
                    delay: frame.delay || 100
                });
                totalTime += (frame.delay || 100);
            }
            return { frames: loadedFrames, duration: totalTime };
        };

        // Upload Handler (FIX L·ªñI)
        document.getElementById('baseImageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            ui.loader.classList.remove('hidden');
            ui.loaderText.textContent = "ƒêang t·∫£i ·∫£nh (B∆∞·ªõc 1/2)...";
            ui.placeholder.classList.add('hidden');
            
            // 1. D√πng FileReader ƒë·ªÉ l·∫•y URL v√† Buffer c√πng l√∫c
            const reader = new FileReader();
            reader.onload = async function() {
                const imgURL = URL.createObjectURL(file);
                
                // 1a. T·∫£i ·∫£nh b·∫±ng Image object (L·∫•y k√≠ch th∆∞·ªõc & Fallback)
                const img = new Image();
                img.src = imgURL;
                await new Promise(resolve => img.onload = resolve);
                
                state.bgImage = await createImageBitmap(img); // S·ª≠ d·ª•ng bitmap ƒë·ªÉ v·∫Ω nhanh h∆°n
                resizeCanvas(img.naturalWidth, img.naturalHeight);
                enableTools(true);
                drawMain(); // Hi·ªÉn th·ªã ·∫£nh tƒ©nh ngay l·∫≠p t·ª©c

                if (file.type === 'image/gif') {
                    ui.loaderText.textContent = "ƒêang ph√¢n t√≠ch GIF (B∆∞·ªõc 2/2)...";
                    const buffer = reader.result; // ArrayBuffer
                    const rawFrames = parseGif(buffer);

                    if (rawFrames && rawFrames.length > 0) {
                        try {
                            const result = await createGifFrames(rawFrames, img.naturalWidth, img.naturalHeight);
                            state.bgGifFrames = result.frames;
                            state.bgGifDuration = result.duration;
                            state.bgType = 'gif';
                            ui.msg.textContent = `‚úÖ ƒê√£ t·∫£i GIF n·ªÅn (${result.frames.length} frames). S·∫µn s√†ng v·∫Ω v√πng m√¥ ph·ªèng.`;
                        } catch(err) {
                            // L·ªói ·ªü b∆∞·ªõc t·∫°o Bitmap t·ª´ frame
                            console.error("L·ªói t·∫°o frame Bitmap:", err);
                            state.bgType = 'image';
                            ui.msg.textContent = "‚ö†Ô∏è T·∫£i th√†nh c√¥ng nh∆∞ng kh√¥ng th·ªÉ gi·∫£i m√£ c√°c frame GIF. S·∫Ω s·ª≠ d·ª•ng ·∫£nh tƒ©nh ƒë·ªÉ m√¥ ph·ªèng.";
                        }
                    } else {
                        // L·ªói ·ªü b∆∞·ªõc parse GIF
                        state.bgType = 'image';
                        ui.msg.textContent = "‚ö†Ô∏è GIF qu√° ph·ª©c t·∫°p, kh√¥ng th·ªÉ ph√¢n t√≠ch frame. S·∫Ω s·ª≠ d·ª•ng ·∫£nh tƒ©nh ƒë·ªÉ m√¥ ph·ªèng.";
                    }
                } else {
                    // ·∫¢nh tƒ©nh
                    state.bgType = 'image';
                    ui.msg.textContent = "‚úÖ ƒê√£ t·∫£i ·∫£nh n·ªÅn tƒ©nh. S·∫µn s√†ng v·∫Ω.";
                }
                
                ui.loader.classList.add('hidden');
            };
            
            // ƒê·ªçc c·∫£ d∆∞·ªõi d·∫°ng URL (cho Image object) v√† ArrayBuffer (cho gifuct-js)
            reader.readAsArrayBuffer(file);
        });
        
        // ... (Gi·ªØ nguy√™n c√°c h√†m kh√°c nh∆∞ resizeCanvas, enableTools, getPos, setMode, update, drawMain, v√† Export GIF)

        document.getElementById('materialImageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                // T·∫£i v·∫≠t li·ªáu d∆∞·ªõi d·∫°ng ImageBitmap
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(resolve => img.onload = resolve);
                state.materialImage = await createImageBitmap(img);
                drawMain();
            }
        });

        function resizeCanvas(w, h) {
            const parent = canvas.parentElement;
            const aspect = w / h;
            
            canvas.width = w;
            canvas.height = h;
            maskCanvas.width = w;
            maskCanvas.height = h;

            if (parent.clientWidth / parent.clientHeight > aspect) {
                canvas.style.height = '100%';
                canvas.style.width = 'auto';
            } else {
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            }
        }

        function enableTools(enable) {
            ui.btnLine.disabled = !enable;
            ui.btnVector.disabled = !enable;
            ui.btnSim.disabled = !enable;
        }

        // --- C√îNG C·ª§ V·∫º ---
        const getPos = (e) => {
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            return {
                x: (e.clientX - r.left) * scaleX,
                y: (e.clientY - r.top) * scaleY
            };
        };

        ui.btnLine.addEventListener('click', () => setMode('line'));
        ui.btnVector.addEventListener('click', () => setMode('vector'));
        document.getElementById('btnReset').addEventListener('click', () => {
            state.paths = [];
            state.particles = [];
            maskCtx.clearRect(0,0,maskCanvas.width, maskCanvas.height);
            drawMain();
        });

        function setMode(m) {
            state.mode = m;
            canvas.classList.toggle('drawing-mode', m !== 'idle');
            ui.msg.textContent = m === 'line' 
                ? "‚úèÔ∏è V·∫Ω Line: K√©o chu·ªôt t·∫°o ƒë∆∞·ªùng d·∫´n." 
                : "üñåÔ∏è V·∫Ω V√πng: V·∫Ω v√≤ng tr√≤n kh√©p k√≠n ƒë·ªÉ ch·ª©a h·∫°t.";
        }

        canvas.addEventListener('mousedown', e => {
            if(state.mode === 'idle') return;
            state.isDrawing = true;
            const p = getPos(e);
            
            if (state.mode === 'line') {
                currentPath = { type: 'line', points: [p] };
            } else {
                currentPath = { type: 'vector', points: [p], drawPoints: [p] };
                maskCtx.beginPath();
                maskCtx.moveTo(p.x, p.y);
            }
        });

        canvas.addEventListener('mousemove', e => {
            if(!state.isDrawing) return;
            const p = getPos(e);
            if(state.mode === 'line') {
                currentPath.points.push(p);
            } else {
                currentPath.drawPoints.push(p);
                maskCtx.lineTo(p.x, p.y);
            }
            drawMain();
        });

        canvas.addEventListener('mouseup', e => {
            if(!state.isDrawing) return;
            state.isDrawing = false;
            
            if(state.mode === 'line') {
                if(currentPath.points.length > 5) {
                    initLinePath(currentPath);
                    state.paths.push(currentPath);
                }
            } else {
                const p = getPos(e);
                maskCtx.lineTo(p.x, p.y);
                maskCtx.closePath();
                maskCtx.fillStyle = '#ffffff'; 
                maskCtx.fill();
                
                currentPath.points.push(p); 
                calcVectorBounds(currentPath);
                initParticles(currentPath);
                state.paths.push(currentPath);
            }
            currentPath = null;
            ui.btnExport.disabled = false;
            drawMain();
        });

        function initLinePath(path) {
            let total = 0;
            path.dists = [0];
            for(let i=1; i<path.points.length; i++){
                total += Math.hypot(path.points[i].x - path.points[i-1].x, path.points[i].y - path.points[i-1].y);
                path.dists.push(total);
            }
            path.length = total;
            initParticles(path);
        }

        function calcVectorBounds(path) {
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            path.drawPoints.forEach(p => {
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
            });
            path.bounds = { minX, maxX, minY, maxY, w: maxX-minX, h: maxY-minY };
            
            const p1 = path.points[0];
            const p2 = path.points[path.points.length-1];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const mag = Math.hypot(dx, dy) || 1;
            path.dir = { x: dx/mag, y: dy/mag };
        }

        function initParticles(path) {
            const density = parseFloat(document.getElementById('rngDensity').value);
            const count = 100 * density;
            for(let i=0; i<count; i++) spawnParticle(path);
        }

        function spawnParticle(path) {
            let p = {
                pathIdx: state.paths.indexOf(path),
                sizeVar: 0.5 + Math.random(),
                speedVar: 0.8 + Math.random()*0.4,
                rot: Math.random() * 6.28
            };

            if(path.type === 'line') {
                p.t = Math.random();
                p.offset = (Math.random()-0.5) * 10;
            } else {
                let ok = false;
                for(let k=0; k<10; k++){
                    p.x = path.bounds.minX + Math.random()*path.bounds.w;
                    p.y = path.bounds.minY + Math.random()*path.bounds.h;
                    // Ki·ªÉm tra s∆° b·ªô:
                    if(p.x >= path.bounds.minX && p.x <= path.bounds.maxX && p.y >= path.bounds.minY && p.y <= path.bounds.maxY) { 
                        ok = true; break; 
                    }
                }
                if(!ok) { p.x = path.bounds.minX; p.y = path.bounds.minY; }
            }
            state.particles.push(p);
        }

        // --- UPDATE & DRAW ---
        ui.btnSim.addEventListener('click', () => {
            state.isSimulating = !state.isSimulating;
            ui.btnSim.textContent = state.isSimulating ? "‚è∏ T·∫†M D·ª™NG" : "‚ñ∂ TI·∫æP T·ª§C";
            if(state.isSimulating) loop();
            else cancelAnimationFrame(animFrameId);
        });

        function loop(timestamp) {
            if(!state.isSimulating) return;
            if(!timestamp) timestamp = performance.now();
            
            const dt = timestamp - (state.lastFrameTime || timestamp);
            state.lastFrameTime = timestamp;
            state.time += dt;

            update(dt);
            drawMain();
            animFrameId = requestAnimationFrame(loop);
        }

        function update(dt) {
            const speed = parseFloat(document.getElementById('rngSpeed').value) * 0.0005 * dt;
            
            state.particles.forEach(p => {
                const path = state.paths[p.pathIdx];
                if(!path) return;

                if(path.type === 'line') {
                    p.t += speed * p.speedVar;
                    if(p.t > 1) p.t = 0;
                } else {
                    const vectorSpeed = speed * 20;
                    p.x += path.dir.x * vectorSpeed * p.speedVar;
                    p.y += path.dir.y * vectorSpeed * p.speedVar;
                    
                    if(p.x < path.bounds.minX || p.x > path.bounds.maxX || 
                       p.y < path.bounds.minY || p.y > path.bounds.maxY) {
                        // Respawn
                        p.x = path.bounds.minX + Math.random()*path.bounds.w;
                        p.y = path.bounds.minY + Math.random()*path.bounds.h;
                    }
                }
            });
        }

        function drawMain() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω N·ªÅn
            if (state.bgType === 'image' && state.bgImage) {
                ctx.drawImage(state.bgImage, 0, 0, canvas.width, canvas.height);
            } 
            else if (state.bgType === 'gif' && state.bgGifFrames.length > 0) {
                const dur = state.bgGifDuration || 1000;
                const t = state.time % dur;
                let acc = 0;
                let frame = state.bgGifFrames[0];
                for(let f of state.bgGifFrames) {
                    acc += f.delay;
                    if(acc >= t) { frame = f; break; }
                    // Fix: ƒê·∫£m b·∫£o frame ƒë·∫ßu ti√™n ƒë∆∞·ª£c v·∫Ω n·∫øu t < delay c·ªßa frame 0
                    if (i === 0 && t < f.delay) { frame = f; break; } 
                }
                ctx.drawImage(frame.bitmap, 0, 0, canvas.width, canvas.height);
            }

            // 2. V·∫Ω n√©t ƒëang v·∫Ω
            if (state.isDrawing && currentPath) {
                ctx.strokeStyle = 'yellow'; ctx.lineWidth = 2;
                ctx.beginPath();
                if(currentPath.type === 'line') {
                    ctx.moveTo(currentPath.points[0].x, currentPath.points[0].y);
                    currentPath.points.forEach(p => ctx.lineTo(p.x, p.y));
                } else {
                    ctx.moveTo(currentPath.drawPoints[0].x, currentPath.drawPoints[0].y);
                    currentPath.drawPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.fillStyle = 'rgba(0,255,255,0.2)'; ctx.fill();
                }
                ctx.stroke();
            }

            // 3. V·∫Ω H·∫°t
            const baseSize = parseInt(document.getElementById('rngSize').value);
            state.particles.forEach(p => {
                const path = state.paths[p.pathIdx];
                let x, y;
                
                if(path.type === 'line') {
                    const d = p.t * path.length;
                    for(let i=1; i<path.dists.length; i++){
                        if(path.dists[i] >= d) {
                            const segLen = path.dists[i] - path.dists[i-1];
                            const r = (d - path.dists[i-1]) / segLen;
                            const p1 = path.points[i-1];
                            const p2 = path.points[i];
                            x = p1.x + (p2.x - p1.x)*r;
                            y = p1.y + (p2.y - p1.y)*r;
                            
                            const ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
                            x += Math.sin(ang)*p.offset;
                            y -= Math.cos(ang)*p.offset;
                            break;
                        }
                    }
                } else {
                    x = p.x; y = p.y;
                }

                if(x !== undefined) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(p.rot);
                    const s = baseSize * p.sizeVar;
                    if(state.materialImage) {
                        ctx.drawImage(state.materialImage, -s/2, -s/2, s, s);
                    } else {
                        ctx.fillStyle = 'orange';
                        ctx.beginPath(); ctx.arc(0,0,s/3,0,6.28); ctx.fill();
                    }
                    ctx.restore();
                }
            });
        }

        // --- EXPORT GIF ---
        ui.btnExport.addEventListener('click', async () => {
             if (state.bgType !== 'gif') {
                alert("Ch·ª©c nƒÉng xu·∫•t GIF n·ªÅn ƒë·ªông y√™u c·∫ßu ·∫£nh n·ªÅn ph·∫£i l√† file GIF ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch th√†nh c√¥ng!");
                // V·∫´n cho ph√©p xu·∫•t, nh∆∞ng n√≥ s·∫Ω l√† n·ªÅn tƒ©nh
            }
            
            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: canvas.width,
                height: canvas.height,
                // S·ª≠ d·ª•ng CDN chu·∫©n cho worker
                workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/gif.worker.js' 
            });

            ui.loader.classList.remove('hidden');
            ui.loaderText.textContent = "ƒêang render GIF...";
            
            const fps = 20;
            const frames = 3 * fps;
            const dt = 1000 / fps;
            
            const realTime = state.time;
            
            for(let i=0; i<frames; i++) {
                state.time += dt;
                update(dt); 
                drawMain(); 
                gif.addFrame(ctx, {copy: true, delay: dt});
                
                ui.loaderText.textContent = `Rendering ${(i/frames*100)|0}%`;
                await new Promise(r => setTimeout(r, 0));
            }

            state.time = realTime;

            ui.loaderText.textContent = "Encoding...";
            gif.on('finished', blob => {
                ui.loader.classList.add('hidden');
                const url = URL.createObjectURL(blob);
                document.getElementById('imgResult').src = url;
                document.getElementById('lnkDownload').href = url;
                document.getElementById('previewArea').classList.remove('hidden');
            });

            gif.render();
        });

    </script>
</body>
</html>
